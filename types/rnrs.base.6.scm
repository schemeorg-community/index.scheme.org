(((name . *) (signature lambda ((number? z) ...) number?) (tags pure))
 ((name . +) (signature lambda ((number? z) ...) number?) (tags pure))
 ((name . -) (signature lambda ((number? z) ...) number?) (tags pure))
 ((name . /)
  (signature lambda ((number? z1) (number? z2) ...) number?)
  (tags pure))
 ((name . <)
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure))
 ((name . <=)
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure))
 ((name . =)
  (signature lambda ((number? z1) (number? z2) (number? z3) ...) boolean?)
  (tags pure))
 ((name . =>)
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure))
 ((name . >)
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure))
 ((name . >=)
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure))
 ((name . abs) (signature lambda ((real? x)) number?) (tags pure))
 ((name . acos) (signature lambda ((number? z)) number?) (tags pure))
 ((name . and) (signature syntax-rules () ((_ test1 ...))))
 ((name . angle) (signature lambda ((complex? z)) real?) (tags pure))
 ((name . append) (signature lambda ((list? list) ...) list?) (tags pure))
 ((name . append) (signature lambda ((list? list) ... obj) *) (tags pure))
 ((name . apply)
  (signature lambda ((procedure? proc) arg1 ... (list? args)) *)
  (tags pure))
 ((name . asin) (signature lambda ((number? z)) number?) (tags pure))
 ((name . assertion-violation) (signature lambda (((or string? symbol? #f) who) (string? message) irritant1 ...) undefined))
 ((name . assert) (signature syntax-rules () ((_ expression))))
 ((name . atan) (signature lambda ((number? z)) number?) (tags pure))
 ((name . begin)
  (signature syntax-rules () ((_ expression-or-definition ...))))
 ((name . boolean=?)
  (signature
   lambda
   ((boolean? boolean1) (boolean? boolean2) (boolean? boolean3) ...)
   boolean?)
  (tags pure))
 ((name . boolean?) (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . caar) (signature lambda ((pair? pair)) *) (tags pure))
 ((name . cadr) (signature lambda ((pair? pair)) *) (tags pure))
 ((name . call-with-current-continuation)
  (signature lambda ((procedure? proc)) *)
  (subsigs (proc (lambda ((procedure? k)) *))))
 ((name . call-with-values)
  (signature lambda ((procedure? producer) (procedure? consumer)) *)
  (tags pure)
  (subsigs (producer (lambda () *)) (consumer (lambda (obj ...) *))))
 ((name . call/cc)
  (signature lambda ((procedure? proc)) *)
  (subsigs (proc (lambda ((procedure? k)) *))))
 ((name . car) (signature lambda ((pair? pair)) *) (tags pure))
 ((name . case)
  (signature syntax-rules (=> else) ((_ key clause1 clause2 ...)))
  (subsigs
   (clause
    ((datum1 ...) expression1 expression2 ...)
    ((datum1 ...) => expression)
    (else expression1 expression2 ...))))
 ((name . cdar) (signature lambda ((pair? pair)) *) (tags pure))
 ((name . cddr) (signature lambda ((pair? pair)) *) (tags pure))
 ((name . cdr) (signature lambda ((pair? pair)) *) (tags pure))
 ((name . ceiling) (signature lambda ((real? x)) real?) (tags pure))
 ((name . char->integer)
  (signature lambda ((char? char)) integer?)
  (tags pure))
 ((name . char<=?)
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . char<?)
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . char=?)
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . char>=?)
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . char>?)
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . char?) (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . complex?)
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (subsigs)
  (supertypes number?))
 ((name . cond)
  (signature syntax-rules (else =>) ((_ clause1 clause2 ...)))
  (subsigs
   (clause
    (test expression1 ...)
    (test => receiver)
    (else expression1 expression2 ...)))
  (syntax-param-signatures
    (receiver procedure?)))
 ((name . cons) (signature lambda (obj1 obj2) pair?) (tags pure))
 ((name . cos) (signature lambda ((number? z)) number?) (tags pure))
 ((name . define)
  (signature
   syntax-rules
   ()
   ((_ variable expression))
   ((_ variable))
   ((_ (variable parameter1 ...) body))
   ((_ (variable parameter1 ... . parameter) body))))
 ((name . define-syntax)
  (signature syntax-rules () ((_ keyword transformer-spec)))
  (syntax-param-signatures (transformer-spec transformer-spec)))
 ((name . denominator) (signature lambda ((rational? q)) integer?) (tags pure))
 ((name . div) (signature lambda ((real? x1) (real? x2)) integer?) (tags pure))
 ((name . div0) (signature lambda ((real? x1) (real? x2)) integer?) (tags pure))
 ((name . div-and-mod) (signature lambda ((real? x1) (real? x2)) (values integer? real?)) (tags pure))
 ((name . div0-and-mod0) (signature lambda ((real? x1) (real? x2)) (values integer? real?)) (tags pure))
 ((name . dynamic-wind)
  (signature
   lambda
   ((procedure? before) (procedure? thunk) (procedure? after))
   *)
  (subsigs
   (before (lambda () undefined))
   (thunk (lambda () *))
   (after (lambda () undefined))))
 ((name . eq?) (signature lambda (obj1 obj2) boolean?) (tags pure))
 ((name . equal?) (signature lambda (obj1 obj2) boolean?) (tags pure))
 ((name . eqv?) (signature lambda (obj1 obj2) boolean?) (tags pure))
 ((name . error) (signature lambda (((or string? symbol? #f) who) (string? message) irritant1 ...) undefined))
 ((name . even?)
  (signature lambda ((integer? n)) boolean?)
  (tags pure predicate))
 ((name . exact) (signature lambda ((number? z)) exact?) (tags pure))
 ((name . exact-integer-sqrt)
  (signature lambda ((integer? k)) (values integer? integer?))
  (tags pure))
 ((name . exact?)
  (signature lambda ((number? z)) boolean?)
  (tags pure)
  (subsigs)
  (supertypes number?))
 ((name . exp) (signature lambda ((number? z)) number?) (tags pure))
 ((name . expt)
  (signature lambda ((number? z1) (number? z2)) number?)
  (tags pure))
 ((name . finite?) (signature lambda ((number? z)) boolean?) (tags pure))
 ((name . floor) (signature lambda ((real? x)) integer?) (tags pure))
 ((name . for-each)
  (signature
   lambda
   ((procedure? proc) (list? list1) (list? list2) ...)
   undefined)
  (subsigs (proc (lambda (obj1 obj2 ...) undefined))))
 ((name . gcd) (signature lambda ((integer? n) ...) integer?) (tags pure))
 ((name . identifier-syntax)
  (signature syntax-rules (set!)
             ((_ template) transformer-spec)
             ((_ (id1 template1)
                 ((set! id2 pattern) template2))))
  (subsigs 
    (pattern
      _
      identifier
      constant
      (pattern ...)
      (pattern pattern ... . pattern)
      (pattern ... pattern ellipsis pattern ...)
      (pattern ... pattern ellipsis pattern ... . pattern)
      (_append "#" (pattern ...))
      (_append "#" (pattern ... pattern ellipsis pattern ...)))
    (template
      identifier
      constant
      (element ...)
      (element element ... . template)
      (ellipsis template)
      (_append "#" (element ...)))))
 ((name . if)
  (signature
   syntax-rules
   ()
   ((_ test consequent))
   ((_ test consequent alternate))))
 ((name . imag-part) (signature lambda ((complex? z)) real?) (tags pure))
 ((name . inexact) (signature lambda ((number? z)) inexact?) (tags pure))
 ((name . inexact?)
  (signature lambda ((number? z)) boolean?)
  (tags pure)
  (subsigs)
  (supertypes number?))
 ((name . infinite?) (signature lambda ((number? z)) boolean?) (tags pure))
 ((name . integer-valued?) (signature lambda (obj) boolean?) (tags pure))
 ((name . integer->char) (signature lambda ((integer? n)) char?) (tags pure))
 ((name . integer?)
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (subsigs)
  (supertypes rational?))
 ((name . lambda)
  (signature syntax-rules () ((_ formals body) procedure?))
  (subsigs
   (formals
    (variable1 ...)
    variable
    (variable1 ... variable_n . variable_n+1))))
 ((name . lcm) (signature lambda ((integer? n) ...) integer?) (tags pure))
 ((name . length) (signature lambda ((list? list)) integer?) (tags pure))
 ((name . let)
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings ((variable1 init1) ...))))
 ((name . let*)
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings ((variable1 init1) ...))))
 ((name . let*-values)
  (signature syntax-rules () ((_ mv-binding-spec body)))
  (subsigs
   (mv-binding-spec ((formals1 init1) ...))
   (formals
    (variable1 ...)
    variable
    (variable1 ... variable_n . variable_n+1))))
 ((name . let-syntax)
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings ((keyword transformer-spec) ...)))
  (syntax-param-signatures (transformer-spec transformer-spec)))
 ((name . let-values)
  (signature syntax-rules () ((_ mv-binding-spec body)))
  (subsigs
   (mv-binding-spec ((formals1 init1) ...))
   (formals
    (variable1 ...)
    variable
    (variable1 ... variable_n . variable_n+1))))
 ((name . letrec)
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings ((variable1 init1) ...))))
 ((name . letrec*)
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings ((variable1 init1) ...))))
 ((name . letrec-syntax)
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings ((keyword transformer-spec) ...))))
 ((name . list) (signature lambda (obj ...) list?) (tags pure))
 ((name . list->string) (signature lambda ((list? list)) string?) (tags pure))
 ((name . list->vector) (signature lambda ((list? list)) vector?) (tags pure))
 ((name . list-ref)
  (signature lambda ((list? list) (integer? k)) *)
  (tags pure))
 ((name . list-tail)
  (signature lambda ((list? list) (integer? k)) list?)
  (tags pure))
 ((name . list?)
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (subsigs)
  (supertypes pair? null?))
 ((name . log) (signature lambda ((number? z)) number?) (tags pure))
 ((name . log)
  (signature lambda ((number? z1) (number? z2)) number?)
  (tags pure))
 ((name . magnitude) (signature lambda ((complex? z)) real?) (tags pure))
 ((name . make-polar)
  (signature lambda ((real? x3) (real? x4)) complex?)
  (tags pure))
 ((name . make-rectangular)
  (signature lambda ((real? x1) (real? x2)) complex?)
  (tags pure))
 ((name . make-string) (signature lambda ((integer? k)) string?))
 ((name . make-string)
  (signature lambda ((integer? k) (char? char)) string?)
  (tags pure))
 ((name . make-vector) (signature lambda ((integer? k)) vector?))
 ((name . make-vector)
  (signature lambda ((integer? k) fill) vector?)
  (tags pure))
 ((name . map)
  (signature lambda ((procedure? proc) (list? list1) (list? list2) ...) list?)
  (tags pure)
  (subsigs (proc (lambda (obj1 obj2 ...) *))))
 ((name . max)
  (signature lambda ((real? x1) (real? x2) ...) real?)
  (tags pure))
 ((name . min)
  (signature lambda ((real? x1) (real? x2) ...) real?)
  (tags pure))
 ((name . mod) (signature lambda ((real? x1) (real? x2)) real?) (tags pure))
 ((name . mod0) (signature lambda ((real? x1) (real? x2)) real?) (tags pure))
 ((name . nan?) (signature lambda ((number? z)) boolean?) (tags pure))
 ((name . negative?) (signature lambda ((real? x)) boolean?) (tags pure))
 ((name . not) (signature lambda (obj) boolean?) (tags pure))
 ((name . null?) (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . number->string) (signature lambda ((number? z)) string?) (tags pure))
 ((name . number->string)
  (signature lambda ((number? z) (integer? radix)) string?)
  (tags pure))
 ((name . number?) (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . numerator) (signature lambda ((rational? q)) integer?) (tags pure))
 ((name . odd?)
  (signature lambda ((integer? n)) boolean?)
  (tags pure predicate))
 ((name . pair?) (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . positive?) (signature lambda ((real? x)) boolean?) (tags pure))
 ((name . procedure?) (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . quasiquote) (signature syntax-rules () ((_ qq-template))))
 ((name . quote) (signature syntax-rules () ((_ datum))))
 ((name . rational-valued?) (signature lambda (obj) boolean?) (tags pure))
 ((name . rational?)
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (subsigs)
  (supertypes real?))
 ((name . rationalize)
  (signature lambda ((real? x) (real? y)) rational?)
  (tags pure))
 ((name . real?)
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (subsigs)
  (supertypes complex?))
 ((name . real-part) (signature lambda ((complex? z)) real?) (tags pure))
 ((name . real-valued?) (signature lambda (obj) boolean?) (tags pure))
 ((name . reverse) (signature lambda ((list? list)) list?) (tags pure))
 ((name . round) (signature lambda ((real? x)) integer?) (tags pure))
 ((name . set!) (signature syntax-rules () ((_ variable expression))))
 ((name . sin) (signature lambda ((number? z)) number?) (tags pure))
 ((name . sqrt) (signature lambda ((number? z)) number?) (tags pure))
 ((name . string) (signature lambda ((char? char) ...) string?) (tags pure))
 ((name . string->list)
  (signature lambda ((string? string)) list?)
  (tags pure))
 ((name . string->list)
  (signature lambda ((string? string) (integer? start)) list?)
  (tags pure))
 ((name . string->list)
  (signature lambda ((string? string) (integer? start) (integer? end)) list?)
  (tags pure))
 ((name . string->number)
  (signature lambda ((string? string)) number?)
  (tags pure))
 ((name . string->number)
  (signature lambda ((string? string) (integer? radix)) number?)
  (tags pure))
 ((name . string->symbol)
  (signature lambda ((string? string)) symbol?)
  (tags pure))
 ((name . string-append)
  (signature lambda ((string? string) ...) string?)
  (tags pure))
 ((name . string-copy)
  (signature lambda ((string? string)) string?)
  (tags pure))
 ((name . string-copy)
  (signature lambda ((string? string) (integer? start)) string?)
  (tags pure))
 ((name . string-copy)
  (signature lambda ((string? string) (integer? start) (integer? end)) string?)
  (tags pure))
 ((name . string-for-each)
  (signature
   lambda
   ((procedure? proc) (string? string1) (string? string2) ...)
   undefined)
  (subsigs (proc (lambda ((string? string) ...) undefined))))
 ((name . string-length)
  (signature lambda ((string? string)) integer?)
  (tags pure))
 ((name . string-ref)
  (signature lambda ((string? string) (integer? k)) char?)
  (tags pure))
 ((name . string<=?)
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . string<?)
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . string=?)
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . string>=?)
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . string>?)
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . string?)
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (subsigs)
  (supertypes textual?))
 ((name . substring)
  (signature lambda ((string? string) (integer? start) (integer? end)) string?)
  (tags pure))
 ((name . symbol->string)
  (signature lambda ((symbol? symbol)) string?)
  (tags pure))
 ((name . symbol=?)
  (signature
   lambda
   ((symbol? symbol1) (symbol? symbol2) (symbol? symbol3) ...)
   boolean?)
  (tags pure))
 ((name . symbol?) (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . syntax-rules)
  (signature
   syntax-rules
   (_)
   ((_ (literal ...) syntax-rule ...) transformer-spec))
  (subsigs
   (syntax-rule (pattern template))
   (pattern
    _
    identifier
    constant
    (pattern ...)
    (pattern pattern ... . pattern)
    (pattern ... pattern ellipsis pattern ...)
    (pattern ... pattern ellipsis pattern ... . pattern)
    (_append "#" (pattern ...))
    (_append "#" (pattern ... pattern ellipsis pattern ...)))
   (template
    identifier
    constant
    (element ...)
    (element element ... . template)
    (ellipsis template)
    (_append "#" (element ...)))
   (element template (_append template ellipsis))))
 ((name . tan) (signature lambda ((number? z)) number?) (tags pure))
 ((name . truncate) (signature lambda ((real? x)) integer?) (tags pure))
 ((name . unquote) (signature syntax-rules () ((_ expression))))
 ((name . unquote-splicing) (signature syntax-rules () ((_ expression))))
 ((name . values) (signature lambda (obj ...) (values * ...)) (tags pure))
 ((name . vector) (signature lambda (obj ...) vector?) (tags pure))
 ((name . vector->list)
  (signature lambda ((vector? vector)) list?)
  (tags pure))
 ((name . vector->list)
  (signature lambda ((vector? vector) (integer? start)) list?)
  (tags pure))
 ((name . vector->list)
  (signature lambda ((vector? vector) (integer? start) (integer? end)) list?)
  (tags pure))
 ((name . vector-fill!) (signature lambda ((vector? vector) fill) undefined))
 ((name . vector-fill!)
  (signature lambda ((vector? vector) fill (integer? start)) undefined))
 ((name . vector-fill!)
  (signature
   lambda
   ((vector? vector) fill (integer? start) (integer? end))
   undefined))
 ((name . vector-for-each)
  (signature
   lambda
   ((procedure? proc) (vector? vector1) (vector? vector2) ...)
   undefined)
  (subsigs (proc (lambda (obj ...) undefined))))
 ((name . vector-length)
  (signature lambda ((vector? vector)) integer?)
  (tags pure))
 ((name . vector-map)
  (signature
   lambda
   ((procedure? proc) (vector? vector1) (vector? vector2) ...)
   vector?)
  (tags pure)
  (subsigs (proc (lambda (obj ...) *))))
 ((name . vector-ref)
  (signature lambda ((vector? vector) (integer? k)) *)
  (tags pure))
 ((name . vector-set!)
  (signature lambda ((vector? vector) (integer? k) obj) undefined))
 ((name . vector?) (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . zero?)
  (signature lambda ((number? z)) boolean?)
  (tags pure predicate)))
