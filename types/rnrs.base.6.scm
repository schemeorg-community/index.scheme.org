(((name . "*") (signature lambda ((number? z) ...) number?) (tags pure))
 ((name . "+") (signature lambda ((number? z) ...) number?) (tags pure))
 ((name . "-") (signature lambda ((number? z) ...) number?) (tags pure))
 ((name . "/")
  (signature lambda ((number? z1) (number? z2) ...) number?)
  (tags pure))
 ((name . "<")
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure))
 ((name . "<=")
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure))
 ((name . "=")
  (signature lambda ((number? z1) (number? z2) (number? z3) ...) boolean?)
  (tags pure))
 ((name . ">")
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure))
 ((name . ">=")
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure))
 ((name . "abs") (signature lambda ((real? x)) number?) (tags pure))
 ((name . "acos") (signature lambda ((number? z)) number?) (tags pure))
 ((name . "and") (signature syntax-rules () ((_ test1 ...))))
 ((name . "angle") (signature lambda ((complex? z)) real?) (tags pure))
 ((name . "append") (signature lambda ((list? list) ...) list?) (tags pure))
 ((name . "append") (signature lambda ((list? list) ... obj) *) (tags pure))
 ((name . "apply")
  (signature lambda ((procedure? proc) arg1 ... (list? args)) *)
  (tags pure))
 ((name . "asin") (signature lambda ((number? z)) number?) (tags pure))
 ((name . "assertion-violation")
  (signature
   lambda
   (((or string? symbol? #f) who) (string? message) irritant1 ...)
   undefined))
 ((name . "assert") (signature syntax-rules () ((_ expression))))
 ((name . "atan") (signature lambda ((number? z)) number?) (tags pure))
 ((name . "begin")
  (signature syntax-rules () ((_ expression-or-definition ...))))
 ((name . "boolean=?")
  (signature
   lambda
   ((boolean? boolean1) (boolean? boolean2) (boolean? boolean3) ...)
   boolean?)
  (tags pure))
 ((name . "boolean?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "caar") (signature lambda ((pair? pair)) *) (tags pure))
 ((name . "cadr") (signature lambda ((pair? pair)) *) (tags pure))
 ((name . "call-with-current-continuation")
  (signature lambda ((procedure? proc)) *)
  (subsigs (proc (lambda ((procedure? k)) *))))
 ((name . "call-with-values")
  (signature lambda ((procedure? producer) (procedure? consumer)) *)
  (subsigs (producer (lambda () *)) (consumer (lambda (obj ...) *)))
  (tags pure))
 ((name . "call/cc")
  (signature lambda ((procedure? proc)) *)
  (subsigs (proc (lambda ((procedure? k)) *))))
 ((name . "car") (signature lambda ((pair? pair)) *) (tags pure))
 ((name . "case")
  (signature syntax-rules (=> else) ((_ key clause1 clause2 ...)))
  (subsigs
   (clause
    (pattern
     ((datum1 ...) expression1 expression2 ...)
     ((datum1 ...) => expression)
     (else expression1 expression2 ...)))))
 ((name . "cdar") (signature lambda ((pair? pair)) *) (tags pure))
 ((name . "cddr") (signature lambda ((pair? pair)) *) (tags pure))
 ((name . "cdr") (signature lambda ((pair? pair)) *) (tags pure))
 ((name . "ceiling") (signature lambda ((real? x)) real?) (tags pure))
 ((name . "char->integer")
  (signature lambda ((char? char)) integer?)
  (tags pure))
 ((name . "char<=?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . "char<?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . "char=?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . "char>=?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . "char>?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure))
 ((name . "char?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "complex?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes number?))
 ((name . "cond")
  (signature syntax-rules (else =>) ((_ clause1 clause2 ...)))
  (subsigs
   (clause
    (pattern
     (test expression1 ...)
     (test => receiver)
     (else expression1 expression2 ...)))
   (receiver (value procedure?))))
 ((name . "cons") (signature lambda (obj1 obj2) pair?) (tags pure))
 ((name . "cos") (signature lambda ((number? z)) number?) (tags pure))
 ((name . "define")
  (signature
   syntax-rules
   ()
   ((_ variable expression))
   ((_ variable))
   ((_ (variable parameter1 ...) body))
   ((_ (variable parameter1 ... . parameter) body))))
 ((name . "define-syntax")
  (signature syntax-rules () ((_ keyword transformer-spec)))
  (subsigs (transformer-spec (value transformer-spec))))
 ((name . "denominator")
  (signature lambda ((rational? q)) integer?)
  (tags pure))
 ((name . "div")
  (signature lambda ((real? x1) (real? x2)) integer?)
  (tags pure))
 ((name . "div0")
  (signature lambda ((real? x1) (real? x2)) integer?)
  (tags pure))
 ((name . "div-and-mod")
  (signature lambda ((real? x1) (real? x2)) (values integer? real?))
  (tags pure))
 ((name . "div0-and-mod0")
  (signature lambda ((real? x1) (real? x2)) (values integer? real?))
  (tags pure))
 ((name . "dynamic-wind")
  (signature
   lambda
   ((procedure? before) (procedure? thunk) (procedure? after))
   *)
  (subsigs
   (before (lambda () undefined))
   (thunk (lambda () *))
   (after (lambda () undefined))))
 ((name . "eq?") (signature lambda (obj1 obj2) boolean?) (tags pure))
 ((name . "equal?") (signature lambda (obj1 obj2) boolean?) (tags pure))
 ((name . "eqv?") (signature lambda (obj1 obj2) boolean?) (tags pure))
 ((name . "error")
  (signature
   lambda
   (((or string? symbol? #f) who) (string? message) irritant1 ...)
   undefined))
 ((name . "even?")
  (signature lambda ((integer? n)) boolean?)
  (tags pure predicate))
 ((name . "exact") (signature lambda ((number? z)) exact?) (tags pure))
 ((name . "exact-integer-sqrt")
  (signature lambda ((integer? k)) (values integer? integer?))
  (tags pure))
 ((name . "exact?")
  (signature lambda ((number? z)) boolean?)
  (tags pure)
  (supertypes number?))
 ((name . "exp") (signature lambda ((number? z)) number?) (tags pure))
 ((name . "expt")
  (signature lambda ((number? z1) (number? z2)) number?)
  (tags pure))
 ((name . "finite?") (signature lambda ((number? z)) boolean?) (tags pure))
 ((name . "floor") (signature lambda ((real? x)) integer?) (tags pure))
 ((name . "for-each")
  (signature
   lambda
   ((procedure? proc) (list? list1) (list? list2) ...)
   undefined)
  (subsigs (proc (lambda (obj1 obj2 ...) undefined))))
 ((name . "gcd") (signature lambda ((integer? n) ...) integer?) (tags pure))
 ((name . "identifier-syntax")
  (signature
   syntax-rules
   (set!)
   ((_ template) transformer-spec)
   ((_ (id1 template1) ((set! id2 pattern) template2))))
  (subsigs
   (pattern
    (pattern
     _
     identifier
     constant
     (pattern ...)
     (pattern pattern ... . pattern)
     (pattern ... pattern ellipsis pattern ...)
     (pattern ... pattern ellipsis pattern ... . pattern)
     (_append "#" (pattern ...))
     (_append "#" (pattern ... pattern ellipsis pattern ...))))
   (template
    (pattern
     identifier
     constant
     (element ...)
     (element element ... . template)
     (ellipsis template)
     (_append "#" (element ...))))))
 ((name . "if")
  (signature
   syntax-rules
   ()
   ((_ test consequent))
   ((_ test consequent alternate))))
 ((name . "imag-part") (signature lambda ((complex? z)) real?) (tags pure))
 ((name . "inexact") (signature lambda ((number? z)) inexact?) (tags pure))
 ((name . "inexact?")
  (signature lambda ((number? z)) boolean?)
  (tags pure)
  (supertypes number?))
 ((name . "infinite?") (signature lambda ((number? z)) boolean?) (tags pure))
 ((name . "integer-valued?") (signature lambda (obj) boolean?) (tags pure))
 ((name . "integer->char") (signature lambda ((integer? n)) char?) (tags pure))
 ((name . "integer?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes rational?))
 ((name . "lambda")
  (signature syntax-rules () ((_ formals body) procedure?))
  (subsigs
   (formals
    (pattern
     (variable1 ...)
     variable
     (variable1 ... variable_n . variable_n+1)))))
 ((name . "lcm") (signature lambda ((integer? n) ...) integer?) (tags pure))
 ((name . "length") (signature lambda ((list? list)) integer?) (tags pure))
 ((name . "let")
  (signature
   syntax-rules
   ()
   ((_ ((var1 init1) ...) body))
   ((_ name ((var1 init1) ...) body))))
 ((name . "let*")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings (pattern ((variable1 init1) ...)))))
 ((name . "let*-values")
  (signature syntax-rules () ((_ mv-binding-spec body)))
  (subsigs
   (mv-binding-spec (pattern ((formals1 init1) ...)))
   (formals
    (pattern
     (variable1 ...)
     variable
     (variable1 ... variable_n . variable_n+1)))))
 ((name . "let-syntax")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs
   (bindings (pattern ((keyword transformer-spec) ...)))
   (transformer-spec (value transformer-spec))))
 ((name . "let-values")
  (signature syntax-rules () ((_ mv-binding-spec body)))
  (subsigs
   (mv-binding-spec (pattern ((formals1 init1) ...)))
   (formals
    (pattern
     (variable1 ...)
     variable
     (variable1 ... variable_n . variable_n+1)))))
 ((name . "letrec")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings (pattern ((variable1 init1) ...)))))
 ((name . "letrec*")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings (pattern ((variable1 init1) ...)))))
 ((name . "letrec-syntax")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings (pattern ((keyword transformer-spec) ...)))))
 ((name . "list") (signature lambda (obj ...) list?) (tags pure))
 ((name . "list->string")
  (signature lambda ((list? list)) string?)
  (tags pure))
 ((name . "list->vector")
  (signature lambda ((list? list)) vector?)
  (tags pure))
 ((name . "list-ref")
  (signature lambda ((list? list) (integer? k)) *)
  (tags pure))
 ((name . "list-tail")
  (signature lambda ((list? list) (integer? k)) list?)
  (tags pure))
 ((name . "list?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes pair? null?))
 ((name . "log") (signature lambda ((number? z)) number?) (tags pure))
 ((name . "log")
  (signature lambda ((number? z1) (number? z2)) number?)
  (tags pure))
 ((name . "magnitude") (signature lambda ((complex? z)) real?) (tags pure))
 ((name . "make-polar")
  (signature lambda ((real? x3) (real? x4)) complex?)
  (tags pure))
 ((name . "make-rectangular")
  (signature lambda ((real? x1) (real? x2)) complex?)
  (tags pure))
 ((name . "make-string") (signature lambda ((integer? k)) string?))
 ((name . "make-string")
  (signature lambda ((integer? k) (char? char)) string?)
  (tags pure))
 ((name . "make-vector") (signature lambda ((integer? k)) vector?))
 ((name . "make-vector")
  (signature lambda ((integer? k) fill) vector?)
  (tags pure))
 ((name . "map")
  (signature lambda ((procedure? proc) (list? list1) (list? list2) ...) list?)
  (subsigs (proc (lambda (obj1 obj2 ...) *)))
  (tags pure))
 ((name . "max")
  (signature lambda ((real? x1) (real? x2) ...) real?)
  (tags pure))
 ((name . "min")
  (signature lambda ((real? x1) (real? x2) ...) real?)
  (tags pure))
 ((name . "mod") (signature lambda ((real? x1) (real? x2)) real?) (tags pure))
 ((name . "mod0") (signature lambda ((real? x1) (real? x2)) real?) (tags pure))
 ((name . "nan?") (signature lambda ((number? z)) boolean?) (tags pure))
 ((name . "negative?") (signature lambda ((real? x)) boolean?) (tags pure))
 ((name . "not") (signature lambda (obj) boolean?) (tags pure))
 ((name . "null?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "number->string")
  (signature lambda ((number? z)) string?)
  (tags pure))
 ((name . "number->string")
  (signature lambda ((number? z) (integer? radix)) string?)
  (tags pure))
 ((name . "number?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "numerator") (signature lambda ((rational? q)) integer?) (tags pure))
 ((name . "odd?")
  (signature lambda ((integer? n)) boolean?)
  (tags pure predicate))
 ((name . "pair?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "positive?") (signature lambda ((real? x)) boolean?) (tags pure))
 ((name . "procedure?")
  (signature lambda (obj) boolean?)
  (tags pure predicate))
 ((name . "quasiquote") (signature syntax-rules () ((_ qq-template))))
 ((name . "quote") (signature syntax-rules () ((_ datum))))
 ((name . "rational-valued?") (signature lambda (obj) boolean?) (tags pure))
 ((name . "rational?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes real?))
 ((name . "rationalize")
  (signature lambda ((real? x) (real? y)) rational?)
  (tags pure))
 ((name . "real?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes complex?))
 ((name . "real-part") (signature lambda ((complex? z)) real?) (tags pure))
 ((name . "real-valued?") (signature lambda (obj) boolean?) (tags pure))
 ((name . "reverse") (signature lambda ((list? list)) list?) (tags pure))
 ((name . "round") (signature lambda ((real? x)) integer?) (tags pure))
 ((name . "set!") (signature syntax-rules () ((_ variable expression))))
 ((name . "sin") (signature lambda ((number? z)) number?) (tags pure))
 ((name . "sqrt") (signature lambda ((number? z)) number?) (tags pure))
 ((name . "string") (signature lambda ((char? char) ...) string?) (tags pure))
 ((name . "string->list")
  (signature lambda ((string? string)) list?)
  (tags pure))
 ((name . "string->list")
  (signature lambda ((string? string) (integer? start)) list?)
  (tags pure))
 ((name . "string->list")
  (signature lambda ((string? string) (integer? start) (integer? end)) list?)
  (tags pure))
 ((name . "string->number")
  (signature lambda ((string? string)) number?)
  (tags pure))
 ((name . "string->number")
  (signature lambda ((string? string) (integer? radix)) number?)
  (tags pure))
 ((name . "string->symbol")
  (signature lambda ((string? string)) symbol?)
  (tags pure))
 ((name . "string-append")
  (signature lambda ((string? string) ...) string?)
  (tags pure))
 ((name . "string-copy")
  (signature lambda ((string? string)) string?)
  (tags pure))
 ((name . "string-copy")
  (signature lambda ((string? string) (integer? start)) string?)
  (tags pure))
 ((name . "string-copy")
  (signature lambda ((string? string) (integer? start) (integer? end)) string?)
  (tags pure))
 ((name . "string-for-each")
  (signature
   lambda
   ((procedure? proc) (string? string1) (string? string2) ...)
   undefined)
  (subsigs (proc (lambda ((string? string) ...) undefined))))
 ((name . "string-length")
  (signature lambda ((string? string)) integer?)
  (tags pure))
 ((name . "string-ref")
  (signature lambda ((string? string) (integer? k)) char?)
  (tags pure))
 ((name . "string<=?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . "string<?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . "string=?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . "string>=?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . "string>?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure))
 ((name . "string?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes textual?))
 ((name . "substring")
  (signature lambda ((string? string) (integer? start) (integer? end)) string?)
  (tags pure))
 ((name . "symbol->string")
  (signature lambda ((symbol? symbol)) string?)
  (tags pure))
 ((name . "symbol=?")
  (signature
   lambda
   ((symbol? symbol1) (symbol? symbol2) (symbol? symbol3) ...)
   boolean?)
  (tags pure))
 ((name . "symbol?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "syntax-rules")
  (signature
   syntax-rules
   (_)
   ((_ (literal ...) syntax-rule ...) transformer-spec))
  (subsigs
   (syntax-rule (pattern (pattern template)))
   (pattern
    (pattern
     _
     identifier
     constant
     (pattern ...)
     (pattern pattern ... . pattern)
     (pattern ... pattern ellipsis pattern ...)
     (pattern ... pattern ellipsis pattern ... . pattern)
     (_append "#" (pattern ...))
     (_append "#" (pattern ... pattern ellipsis pattern ...))))
   (template
    (pattern
     identifier
     constant
     (element ...)
     (element element ... . template)
     (ellipsis template)
     (_append "#" (element ...))))
   (element (pattern template (_append template ellipsis)))))
 ((name . "tan") (signature lambda ((number? z)) number?) (tags pure))
 ((name . "truncate") (signature lambda ((real? x)) integer?) (tags pure))
 ((name . "unquote") (signature syntax-rules () ((_ expression))))
 ((name . "unquote-splicing") (signature syntax-rules () ((_ expression))))
 ((name . "values") (signature lambda (obj ...) (values * ...)) (tags pure))
 ((name . "vector") (signature lambda (obj ...) vector?) (tags pure))
 ((name . "vector->list")
  (signature lambda ((vector? vector)) list?)
  (tags pure))
 ((name . "vector->list")
  (signature lambda ((vector? vector) (integer? start)) list?)
  (tags pure))
 ((name . "vector->list")
  (signature lambda ((vector? vector) (integer? start) (integer? end)) list?)
  (tags pure))
 ((name . "vector-fill!") (signature lambda ((vector? vector) fill) undefined))
 ((name . "vector-fill!")
  (signature lambda ((vector? vector) fill (integer? start)) undefined))
 ((name . "vector-fill!")
  (signature
   lambda
   ((vector? vector) fill (integer? start) (integer? end))
   undefined))
 ((name . "vector-for-each")
  (signature
   lambda
   ((procedure? proc) (vector? vector1) (vector? vector2) ...)
   undefined)
  (subsigs (proc (lambda (obj ...) undefined))))
 ((name . "vector-length")
  (signature lambda ((vector? vector)) integer?)
  (tags pure))
 ((name . "vector-map")
  (signature
   lambda
   ((procedure? proc) (vector? vector1) (vector? vector2) ...)
   vector?)
  (subsigs (proc (lambda (obj ...) *)))
  (tags pure))
 ((name . "vector-ref")
  (signature lambda ((vector? vector) (integer? k)) *)
  (tags pure))
 ((name . "vector-set!")
  (signature lambda ((vector? vector) (integer? k) obj) undefined))
 ((name . "vector?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "zero?")
  (signature lambda ((number? z)) boolean?)
  (tags pure predicate)))
