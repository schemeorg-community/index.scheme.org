(((name . "cons")
  (signature lambda (a d) pair?)
  (tags pure)
  (desc . "The primitive constructor. Returns a newly allocated pair whose car is a and whose cdr is d. The pair is guaranteed to be different (in the sense of eqv?) from every existing object."))
 ((name . "list")
  (signature lambda (object ...) list?)
  (tags pure)
  (desc . "Returns a newly allocated list of its arguments."))
 ((name . "xcons")
  (signature lambda (d a) pair?)
  (tags pure)
  (desc . "(lambda (d a) (cons a d)) Of utility only as a value to be conveniently passed to higher-order procedures."))
 ((name . "cons*")
  (signature lambda (elt1 elt2 ...) *)
  (tags pure)
  (desc . "Like list, but the last argument provides the tail of the constructed list, returning (cons elt1 (cons elt2 (cons ... eltn))). This function is called list* in Common Lisp and about half of the Schemes that provide it, and cons* in the other half."))
 ((name . "make-list")
  (signature case-lambda (((integer? n)) list?) (((integer? n) fill) list?))
  (tags pure)
  (desc . "Returns an n-element list, whose elements are all the value fill. If the fill argument is not given, the elements of the list may be arbitrary values."))
 ((name . "list-tabulate")
  (signature lambda ((integer? n) (procedure? init-proc)) list?)
  (subsigs (init-proc (lambda ((integer? i)) *)))
  (tags pure)
  (desc . "Returns an n-element list. Element i of the list, where 0 <= i < n, is produced by (init-proc i). No guarantee is made about the dynamic order in which init-proc is applied to these indices."))
 ((name . "list-copy")
  (signature
   case-lambda
   (((list? flist)) list?)
   (((dotted-list? flist)) dotted-list?))
  (tags pure)
  (desc . "Copies the spine of the argument."))
 ((name . "circular-list")
  (signature lambda (elt1 elt2 ...) circular-list?)
  (tags pure)
  (desc . "Constructs a circular list of the elements."))
 ((name . "iota")
  (signature
   case-lambda
   (((integer? count)) list?)
   (((integer? count) (number? start)) list?)
   (((integer? count) (number? start) (number? step)) list?))
  (tags pure)
  (desc . "Returns a list containing the elements (start start+step ... start+(count-1)*step). The start and step parameters default to 0 and 1, respectively. This procedure takes its name from the APL primitive."))
 ((name . "proper-list?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns true iff x is a proper list -- a finite, nil-terminated list. More carefully: The empty list is a proper list. A pair whose cdr is a proper list is also a proper list: <proper-list> ::= () | (cons <x> <proper-list>).  Note that this definition rules out circular lists. This function is required to detect this case and return false. Nil-terminated lists are called \"proper\" lists by R5RS and Common Lisp. The opposite of proper is improper."))
 ((name . "circular-list?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "True if x is a circular list. A circular list is a value such that for every n >= 0, cdrn(x) is a pair. Terminology: The opposite of circular is finite."))
 ((name . "dotted-list?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "True if x is a finite, non-nil-terminated list. That is, there exists an n >= 0 such that cdrn(x) is neither a pair nor (). This includes non-pair, non-() values (e.g. symbols, numbers), which are considered to be dotted lists of length 0."))
 ((name . "pair?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if object is a pair; otherwise, #f."))
 ((name . "null?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if object is the empty list; otherwise, #f."))
 ((name . "null-list?")
  (signature
   case-lambda
   (((list? lst)) boolean?)
   (((circular-list? lst)) boolean?))
  (tags pure predicate)
  (desc . "List is a proper or circular list. This procedure returns true if the argument is the empty list (), and false otherwise. It is an error to pass this procedure a value which is not a proper or circular list. This procedure is recommended as the termination condition for list-processing procedures that are not defined on dotted lists."))
 ((name . "not-pair?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "(lambda (x) (not (pair? x))). Provided as a procedure as it can be useful as the termination condition for list-processing procedures that wish to handle all finite lists, both proper and dotted."))
 ((name . "list=")
  (signature lambda ((procedure? elt=) (list? list1) ...) boolean?)
  (subsigs (elt= (lambda (a b) *)))
  (tags pure)
  (desc . "Determines list equality, given an element-equality procedure. Proper list A equals proper list B if they are of the same length, and their corresponding elements are equal, as determined by elt=. If the element-comparison procedure's first argument is from listi, then its second argument is from listi+1, i.e. it is always called as (elt= a b) for a an element of list A, and b an element of list B. In the n-ary case, every listi is compared to listi+1 (as opposed, for example, to comparing list1 to every listi, for i>1). If there are no list arguments at all, list= simply returns true. It is an error to apply list= to anything except proper lists. While implementations may choose to extend it to circular lists, note that it cannot reasonably be extended to dotted lists, as it provides no way to specify an equality procedure for comparing the list terminators. Note that the dynamic order in which the elt= procedure is applied to pairs of elements is not specified. For example, if list= is applied to three lists, A, B, and C, it may first completely compare A to B, then compare B to C, or it may compare the first elements of A and B, then the first elements of B and C, then the second elements of A and B, and so forth. The equality procedure must be consistent with eq?. That is, it must be the case that (eq? x y) => (elt= x y). Note that this implies that two lists which are eq? are always list=, as well; implementations may exploit this fact to \"short-cut\" the element-by-element comparisons."))
 ((name . "caar")
  (signature lambda ((pair? pair)) *)
  (tags pure)
  (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cadr")
  (signature lambda ((pair? pair)) *)
  (tags pure)
  (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "car")
  (signature lambda ((pair? pair)) *)
  (tags pure)
  (desc . "car, cdr These functions return the contents of the car and cdr field of their argument, respectively. Note that it is an error to apply them to the empty list."))
 ((name . "cdar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cddr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cdr")
  (signature lambda ((pair? pair)) *)
  (tags pure)
  (desc . "car, cdr These functions return the contents of the car and cdr field of their argument, respectively. Note that it is an error to apply them to the empty list."))
 ((name . "caaaar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "caaadr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "caaar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "caadar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "caaddr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "caadr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cadaar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cadadr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cadar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "caddar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cadddr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "caddr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cdaaar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cdaadr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cdaar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cdadar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cdaddr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cdadr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cddaar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cddadr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cddar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cdddar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cddddr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "cdddr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "caar, cadr, ..., cddddr These procedures are compositions of car and cdr, where for example caddr could be defined by (define caddr (lambda (x) (car (cdr (cdr x)))))."))
 ((name . "list-ref")
  (signature
   case-lambda
   (((list? clist) (integer? i)) *)
   (((circular-list? clist) (integer? i)) *))
  (tags pure)
  (desc . "Returns the ith element of clist. (This is the same as the car of (drop clist i).) It is an error if i >= n, where n is the length of clist."))
 ((group
    ((name . "first") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "second") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "third") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "fourth") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "fifth") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "sixth") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "seventh") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "eighth") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "ninth") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "tenth") (signature lambda ((pair? pair)) *) (tags pure)))
  (desc . "Synonyms for car, cadr, caddr, ... "))
 ((name . "car+cdr")
  (signature lambda ((pair? pair)) (values * *))
  (tags pure)
  (desc . "The fundamental pair deconstructor: (lambda (p) (values (car p) (cdr p)))"))
 ((name . "take")
  (signature
   case-lambda
   (((list? x) (integer? i)) list?)
   (((circular-list? x) (integer? i)) list?)
   (((dotted-list? x) (integer? i)) list?))
  (tags pure)
  (desc . "take, drop take returns the first i elements of list x. drop returns all but the first i elements of list x. x may be any value -- a proper, circular, or dotted list. For a legal i, take and drop partition the list in a manner which can be inverted with append: (append (take x i) (drop x i)) = x. drop is exactly equivalent to performing i cdr operations on x; the returned value shares a common tail with x. If the argument is a list of non-zero length, take is guaranteed to return a freshly-allocated list, even in the case where the entire list is taken, e.g. (take lis (length lis))."))
 ((name . "drop")
  (signature
   case-lambda
   (((list? x) (integer? i)) list?)
   (((circular-list? x) (integer? i)) circular-list?)
   (((dotted-list? x) (integer? i)) *))
  (tags pure)
  (desc . "take, drop take returns the first i elements of list x. drop returns all but the first i elements of list x. x may be any value -- a proper, circular, or dotted list. For a legal i, take and drop partition the list in a manner which can be inverted with append: (append (take x i) (drop x i)) = x. drop is exactly equivalent to performing i cdr operations on x; the returned value shares a common tail with x. If the argument is a list of non-zero length, take is guaranteed to return a freshly-allocated list, even in the case where the entire list is taken, e.g. (take lis (length lis))."))
 ((name . "take-right")
  (signature
   case-lambda
   (((list? flist) (integer? i)) list?)
   (((dotted-list? flist) (integer? i)) *))
  (tags pure)
  (desc . "take-right, drop right take-right returns the last i elements of flist. drop-right returns all but the last i elements of flist.  The returned list may share a common tail with the argument list. flist may be any finite list, either proper or dotted.  For a legal i, take-right and drop-right partition the list in a manner which can be inverted with append: (append (take flist i) (drop flist i)) = flist. take-right's return value is guaranteed to share a common tail with flist. If the argument is a list of non-zero length, drop-right is guaranteed to return a freshly-allocated list, even in the case where nothing is dropped, e.g. (drop-right lis 0)."))
 ((name . "drop-right")
  (signature
   case-lambda
   (((list? flist) (integer? i)) list?)
   (((dotted-list? flist) (integer? i)) list?))
  (tags pure)
  (desc . "take-right, drop right take-right returns the last i elements of flist. drop-right returns all but the last i elements of flist.  The returned list may share a common tail with the argument list. flist may be any finite list, either proper or dotted.  For a legal i, take-right and drop-right partition the list in a manner which can be inverted with append: (append (take flist i) (drop flist i)) = flist. take-right's return value is guaranteed to share a common tail with flist. If the argument is a list of non-zero length, drop-right is guaranteed to return a freshly-allocated list, even in the case where nothing is dropped, e.g. (drop-right lis 0)."))
 ((name . "take!")
  (signature
   case-lambda
   (((list? x) (integer? i)) list?)
   (((circular-list? x) (integer? i)) list?)
   (((dotted-list? x) (integer? i)) list?))
  (desc . "take!, drop-right!  take! and drop-right! are \"linear-update\" variants of take and drop-right: the procedure is allowed, but not required, to alter the argument list to produce the result. If x is circular, take! may return a shorter-than-expected list"))
 ((name . "drop-right!")
  (signature
   case-lambda
   (((list? flist) (integer? i)) list?)
   (((dotted-list? flist) (integer? i)) list?))
  (desc . "take!, drop-right!  take! and drop-right! are \"linear-update\" variants of take and drop-right: the procedure is allowed, but not required, to alter the argument list to produce the result. If x is circular, take! may return a shorter-than-expected list"))
 ((name . "split-at")
  (signature
   case-lambda
   (((list? x) (integer? i)) (values list? list?))
   (((circular-list? x) (integer? i)) (values list? circular-list?))
   (((dotted-list? x) (integer? i)) (values list? *)))
  (tags pure)
  (desc . "split-at, split-at! split-at splits the list x at index i, returning a list of the first i elements, and the remaining tail. It is equivalent to (values (take x i) (drop x i)). split-at! is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result."))
 ((name . "split-at!")
  (signature
   case-lambda
   (((list? x) (integer? i)) (values list? list?))
   (((circular-list? x) (integer? i)) (values list? circular-list?))
   (((dotted-list? x) (integer? i)) (values list? *)))
  (desc . "split-at, split-at! split-at splits the list x at index i, returning a list of the first i elements, and the remaining tail. It is equivalent to (values (take x i) (drop x i)). split-at! is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result."))
 ((name . "last")
  (signature lambda ((list? pair)) *)
  (tags pure)
  (desc . "last, last-pair last returns the last element of the non-empty, finite list pair. last-pair returns the last pair in the non-empty, finite list pair."))
 ((name . "last-pair") (signature lambda ((list? pair)) pair?) (tags pure) (desc . "last, last-pair last returns the last element of the non-empty, finite list pair. last-pair returns the last pair in the non-empty, finite list pair."))
 ((name . "length")
  (signature lambda ((list? list)) integer?)
  (tags pure)
  (desc . "length, length+ Both length and length+ return the length of the argument. It is an error to pass a value to length which is not a proper list (finite and nil-terminated). In particular, this means an implementation may diverge or signal an error when length is applied to a circular list. length+, on the other hand, returns #F when applied to a circular list. The length of a proper list is a non-negative integer n such that cdr applied n times to the list produces the empty list."))
 ((name . "length+")
  (signature
   case-lambda
   (((list? clist)) integer?)
   (((circular-list? clist)) boolean?))
  (tags pure)
  (desc . "length, length+ Both length and length+ return the length of the argument. It is an error to pass a value to length which is not a proper list (finite and nil-terminated). In particular, this means an implementation may diverge or signal an error when length is applied to a circular list. length+, on the other hand, returns #F when applied to a circular list. The length of a proper list is a non-negative integer n such that cdr applied n times to the list produces the empty list."))
 ((name . "append")
  (signature case-lambda (((list? list) ...) list?) (((list? list) ... obj) *))
  (tags pure)
  (desc . "append, append! append returns a list consisting of the elements of list1 followed by the elements of the other list parameters. The resulting list is always newly allocated, except that it shares structure with the final listi argument. This last argument may be any value at all; an improper list results if it is not a proper list. All other arguments must be proper lists. append! is the \"linear-update\" variant of append -- it is allowed, but not required, to alter cons cells in the argument lists to construct the result list. The last argument is never altered; the result list shares structure with this parameter."))
 ((name . "append!")
  (signature
   case-lambda
   (((list? list) ...) list?)
   (((list? list) ... obj) *))
  (desc . "append, append! append returns a list consisting of the elements of list1 followed by the elements of the other list parameters. The resulting list is always newly allocated, except that it shares structure with the final listi argument. This last argument may be any value at all; an improper list results if it is not a proper list. All other arguments must be proper lists. append! is the \"linear-update\" variant of append -- it is allowed, but not required, to alter cons cells in the argument lists to construct the result list. The last argument is never altered; the result list shares structure with this parameter."))
 ((name . "concatenate")
  (signature lambda ((list? list-of-lists)) *)
  (tags pure)
  (subsigs
   (list-of-lists (list (list? lst))))
  (desc . "concatenate, concatenate! These functions append the elements of their argument together. That is, concatenate returns (apply append list-of-lists) or, equivalently, (reduce-right append '() list-of-lists). concatenate! is the linear-update variant, defined in terms of append! instead of append. Note that some Scheme implementations do not support passing more than a certain number (e.g., 64) of arguments to an n-ary procedure. In these implementations, the (apply append ...) idiom would fail when applied to long lists, but concatenate would continue to function properly. As with append and append!, the last element of the input list may be any value at all."))
 ((name . "concatenate!")
  (signature lambda ((list? list-of-lists)) *)
  (subsigs
   (list-of-lists (list (list? lst))))
  (desc . "concatenate, concatenate! These functions append the elements of their argument together. That is, concatenate returns (apply append list-of-lists) or, equivalently, (reduce-right append '() list-of-lists). concatenate! is the linear-update variant, defined in terms of append! instead of append. Note that some Scheme implementations do not support passing more than a certain number (e.g., 64) of arguments to an n-ary procedure. In these implementations, the (apply append ...) idiom would fail when applied to long lists, but concatenate would continue to function properly. As with append and append!, the last element of the input list may be any value at all."))
 ((name . "reverse")
  (signature lambda ((list? list)) list?)
  (tags pure)
  (desc . "reverse, reverse! reverse returns a newly allocated list consisting of the elements of list in reverse order. reverse! is the linear-update variant of reverse. It is permitted, but not required, to alter the argument's cons cells to produce the reversed list."))
 ((name . "reverse!")
  (signature lambda ((list? list)) list?)
  (desc . "reverse, reverse! reverse returns a newly allocated list consisting of the elements of list in reverse order. reverse! is the linear-update variant of reverse. It is permitted, but not required, to alter the argument's cons cells to produce the reversed list."))
 ((name . "append-reverse")
  (signature
   case-lambda
   (((list? rev-head) (list? tail)) list?)
   (((list? rev-head) tail) *))
  (tags pure)
  (desc . "append-reverse, append-reverse! append-reverse returns (append (reverse rev-head) tail). It is provided because it is a common operation -- a common list-processing style calls for this exact operation to transfer values accumulated in reverse order onto the front of another list, and because the implementation is significantly more efficient than the simple composition it replaces. (But note that this pattern of iterative computation followed by a reverse can frequently be rewritten as a recursion, dispensing with the reverse and append-reverse steps, and shifting temporary, intermediate storage from the heap to the stack, which is typically a win for reasons of cache locality and eager storage reclamation.) append-reverse! is just the linear-update variant -- it is allowed, but not required, to alter rev-head's cons cells to construct the result."))
 ((name . "append-reverse!")
  (signature
   case-lambda
   (((list? rev-head) (list? tail)) list?)
   (((list? rev-head) tail) *))
  (desc . "append-reverse, append-reverse! append-reverse returns (append (reverse rev-head) tail). It is provided because it is a common operation -- a common list-processing style calls for this exact operation to transfer values accumulated in reverse order onto the front of another list, and because the implementation is significantly more efficient than the simple composition it replaces. (But note that this pattern of iterative computation followed by a reverse can frequently be rewritten as a recursion, dispensing with the reverse and append-reverse steps, and shifting temporary, intermediate storage from the heap to the stack, which is typically a win for reasons of cache locality and eager storage reclamation.) append-reverse! is just the linear-update variant -- it is allowed, but not required, to alter rev-head's cons cells to construct the result."))
 ((name . "zip")
  (signature lambda ((list? clist1) (list? clist2) ...) list?)
  (tags pure)
  (desc . "(lambda lists (apply map list lists)). If zip is passed n lists, it returns a list as long as the shortest of these lists, each element of which is an n-element list comprised of the corresponding elements from the parameter lists. At least one of the argument lists must be finite."))
 ((name . "unzip1")
  (signature lambda ((list? list)) list?)
  (tags pure)
  (desc . "unzip1 takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns (map car lists). unzip2 takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. unzip3 does the same for the first three elements of the lists, and so forth."))
 ((name . "unzip2")
  (signature lambda ((list? list)) (values list? list?))
  (tags pure)
  (desc . "unzip1 takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns (map car lists). unzip2 takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. unzip3 does the same for the first three elements of the lists, and so forth."))
 ((name . "unzip3")
  (signature lambda ((list? list)) (values list? list? list?))
  (tags pure)
  (desc . "unzip1 takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns (map car lists). unzip2 takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. unzip3 does the same for the first three elements of the lists, and so forth."))
 ((name . "unzip4")
  (signature lambda ((list? list)) (values list? list? list? list?))
  (tags pure)
  (desc . "unzip1 takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns (map car lists). unzip2 takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. unzip3 does the same for the first three elements of the lists, and so forth."))
 ((name . "unzip5")
  (signature lambda ((list? list)) (values list? list? list? list? list?))
  (tags pure)
  (desc . "unzip1 takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns (map car lists). unzip2 takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. unzip3 does the same for the first three elements of the lists, and so forth."))
 ((name . "count")
  (signature
   lambda
   ((procedure? pred) (list? clist1) (list? clist2) ...)
   integer?)
  (subsigs (pred (lambda (obj ...) *)))
  (tags pure)
  (desc . "pred is a procedure taking as many arguments as there are lists and returning a single value. It is applied element-wise to the elements of the lists, and a count is tallied of the number of elements that produce a true value. This count is returned. count is \"iterative\" in that it is guaranteed to apply pred to the list elements in a left-to-right order. The counting stops when the shortest list expires. At least one of the argument lists must be finite."))
 ((name . "fold")
  (signature
   lambda
   ((procedure? kons) knil (list? clist1) (list? clist2) ...)
   *)
  (subsigs (kons (lambda (obj1 obj2 ... fold-state) *)))
  (tags pure)
  (desc . "The fundamental list iterator. First, consider the single list-parameter case. If clist1 = (e1 e2 ... en), then this procedure returns (kons en ... (kons e2 (kons e1 knil)) ... ). If n list arguments are provided, then the kons function must take n+1 parameters: one element from each list, and the \"seed\" or fold state, which is initially knil. The fold operation terminates when the shortest list runs out of values. At least one of the list arguments must be finite."))
 ((name . "fold-right")
  (signature
   lambda
   ((procedure? kons) knil (list? clist1) (list? clist2) ...)
   *)
  (subsigs (kons (lambda (obj1 obj2 ... fold-state) *)))
  (tags pure)
  (desc . " The fundamental list recursion operator. First, consider the single list-parameter case. If clist1 = (e1 e2 ... en), then this procedure returns (kons e1 (kons e2 ... (kons en knil))). If n list arguments are provided, then the kons function must take n+1 parameters: one element from each list, and the \"seed\" or fold state, which is initially knil. The fold operation terminates when the shortest list runs out of values. At least one of the list arguments must be finite."))
 ((name . "pair-fold")
  (signature
   lambda
   ((procedure? kons) knil (list? clist1) (list? clist2) ...)
   *)
  (subsigs (kons (lambda ((pair? pair1) (pair? pair2) ... fold-state) *)))
  (tags pure)
  (desc . "Analogous to fold, but kons is applied to successive sublists of the lists, rather than successive elements -- that is, kons is applied to the pairs making up the lists. For finite lists, the kons function may reliably apply set-cdr! to the pairs it is given without altering the sequence of execution. At least one of the list arguments must be finite."))
 ((name . "pair-fold-right")
  (signature
   lambda
   ((procedure? kons) knil (list? clist1) (list? clist2) ...)
   *)
  (subsigs (kons (lambda ((pair? pair1) (pair? pair2) ... fold-state) *)))
  (tags pure)
  (desc . "Holds the same relationship with fold-right that pair-fold holds with fold. At least one of the list arguments must be finite."))
 ((name . "reduce")
  (signature lambda ((procedure? f) ridentity (list? list)) *)
  (subsigs (f (lambda (obj fold-state) *)))
  (tags pure)
  (desc . " reduce is a variant of fold. ridentity should be a \"right identity\" of the procedure f -- that is, for any value x acceptable to f, (f x ridentity) = x. reduce has the following definition: If list = (), return ridentity; Otherwise, return (fold f (car list) (cdr list)). ...in other words, we compute (fold f ridentity list). Note that ridentity is used only in the empty-list case. You typically use reduce when applying f is expensive and you'd like to avoid the extra application incurred when fold applies f to the head of list and the identity value, redundantly producing the same value passed in to f. For example, if f involves searching a file directory or performing a database query, this can be significant. In general, however, fold is useful in many contexts where reduce is not (consider the examples given in the fold definition -- only one of the five folds uses a function with a right identity. The other four may not be performed with reduce). Note: MIT Scheme and Haskell flip F's arg order for their reduce and fold functions."))
 ((name . "reduce-right")
  (signature lambda ((procedure? f) ridentity (list? list)) *)
  (subsigs (f (lambda (obj fold-state) *)))
  (tags pure)
  (desc . "reduce-right is the fold-right variant of reduce."))
 ((name . "unfold")
  (signature
   case-lambda
   (((procedure? p) (procedure? f) (procedure? g) seed) list?)
   (((procedure? p) (procedure? f) (procedure? g) seed (list? tail-gen)) *))
  (subsigs
   (p (lambda (seed) boolean?))
   (f (lambda (seed) *))
   (g (lambda (seed) *))
   (tail-gen (lambda () *)))
  (tags pure)
  (desc . " unfold is best described by its basic recursion: (unfold p f g seed) = (if (p seed) (tail-gen seed) (cons (f seed) (unfold p f g (g seed)))). p determines when to stop unfolding. f maps each seed value to the corresponding list element. g maps each seed value to next seed value. seed the \"state\" value for the unfold. tail-gen creates the tail of the list; defaults to (lambda (x) '()). In other words, we use g to generate a sequence of seed values seed, g(seed), g2(seed), g3(seed), ... These seed values are mapped to list elements by f, producing the elements of the result list in a left-to-right order. P says when to stop. unfold is the fundamental recursive list constructor, just as fold-right is the fundamental recursive list consumer."))
 ((name . "unfold-right")
  (signature
   case-lambda
   (((procedure? p) (procedure? f) (procedure? g) seed) list?)
   (((procedure? p) (procedure? f) (procedure? g) seed (list? tail-gen)) *))
  (subsigs
   (p (lambda (seed) boolean?))
   (f (lambda (seed) *))
   (g (lambda (seed) *))
   (tail-gen (lambda () *)))
  (tags pure)
  (desc . "unfold-right constructs a list with the following loop: (let lp ((seed seed) (lis tail)) (if (p seed) lis (lp (g seed) (cons (f seed) lis)))). p determines when to stop unfolding. f maps each seed value to the corresponding list element. g maps each seed value to next seed value. seed the \"state\" value for the unfold. tail list terminator; defaults to '(). In other words, we use g to generate a sequence of seed values seed, g(seed), g2(seed), g3(seed), ... These seed values are mapped to list elements by f, producing the elements of the result list in a right-to-left order. P says when to stop. unfold-right is the fundamental iterative list constructor, just as fold is the fundamental iterative list consumer."))
 ((name . "map")
  (signature lambda ((procedure? proc) (list? list1) (list? list2) ...) list?)
  (subsigs (proc (lambda (obj1 obj2 ...) *)))
  (tags pure)
  (desc . "proc is a procedure taking as many arguments as there are list arguments and returning a single value. map applies proc element-wise to the elements of the lists and returns a list of the results, in order. The dynamic order in which proc is applied to the elements of the lists is unspecified. his procedure is extended from its R5RS specification to allow the arguments to be of unequal length; it terminates when the shortest list runs out. At least one of the argument lists must be finite."))
 ((name . "for-each")
  (signature
   lambda
   ((procedure? proc) (list? list1) (list? list2) ...)
   undefined)
  (subsigs (proc (lambda (obj1 obj2 ...) undefined)))
  (desc . "The arguments to for-each are like the arguments to map, but for-each calls proc for its side effects rather than for its values. Unlike map, for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified.  This procedure is extended from its R5RS specification to allow the arguments to be of unequal length; it terminates when the shortest list runs out. At least one of the argument lists must be finite. "))
 ((name . "append-map")
  (signature lambda ((procedure? proc) (list? list1) (list? list2) ...) list?)
  (subsigs (proc (lambda (obj1 obj2 ...) list?)))
  (tags pure)
  (desc . "append-map, append-map!  Equivalent to (apply append (map f clist1 clist2 ...)) and (apply append! (map f clist1 clist2 ...)). Map f over the elements of the lists, just as in the map function. However, the results of the applications are appended together to make the final result. append-map uses append to append the results together; append-map! uses append!. The dynamic order in which the various applications of f are made is not specified."))
 ((name . "append-map!")
  (signature lambda ((procedure? proc) (list? list1) (list? list2) ...) list?)
  (subsigs (proc (lambda (obj1 objs2 ...) list?)))
  (desc . "append-map, append-map!  Equivalent to (apply append (map f clist1 clist2 ...)) and (apply append! (map f clist1 clist2 ...)). Map f over the elements of the lists, just as in the map function. However, the results of the applications are appended together to make the final result. append-map uses append to append the results together; append-map! uses append!. The dynamic order in which the various applications of f are made is not specified."))
 ((name . "map!")
  (signature lambda ((procedure? proc) (list? list1) (list? list2) ...) list?)
  (subsigs (proc (lambda (obj1 obj2 ...) *)))
  (desc . "Linear-update variant of map -- map! is allowed, but not required, to alter the cons cells of list1 to construct the result list. The dynamic order in which the various applications of f are made is not specified. In the n-ary case, clist2, clist3, ... must have at least as many elements as list1."))
 ((name . "map-in-order")
  (signature lambda ((procedure? proc) (list? list1) (list? list2) ...) list?)
  (subsigs (proc (lambda (obj1 obj2 ...) *)))
  (desc . "A variant of the map procedure that guarantees to apply f across the elements of the listi arguments in a left-to-right order. This is useful for mapping procedures that both have side effects and return useful values. At least one of the list arguments must be finite."))
 ((name . "pair-for-each")
  (signature
   lambda
   ((procedure? proc) (list? list1) (list? list2) ...)
   undefined)
  (subsigs (proc (lambda ((pair? obj1) (pair? obj2) ...) undefined)))
  (desc . " Like for-each, but f is applied to successive sublists of the argument lists. That is, f is applied to the cons cells of the lists, rather than the lists' elements. These applications occur in left-to-right order. The f procedure may reliably apply set-cdr! to the pairs it is given without altering the sequence of execution."))
 ((name . "filter-map")
  (signature lambda ((procedure? proc) (list? list1) (list? list2) ...) list?)
  (subsigs (proc (lambda (obj1 obj2 ...) *)))
  (tags pure)
  (desc . "Like map, but only true values are saved.  The dynamic order in which the various applications of f are made is not specified. At least one of the list arguments must be finite."))
 ((name . "filter")
  (signature lambda ((procedure? pred) (list? list)) list?)
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "Return all the elements of list that satisfy predicate pred. The list is not disordered -- elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of pred are made is not specified."))
 ((name . "filter!")
  (signature lambda ((procedure? pred) (list? list)) list?)
  (subsigs (pred (lambda (obj) *)))
  (desc . "filter!, partition!, remove! Linear-update variants of filter, partition and remove. These procedures are allowed, but not required, to alter the cons cells in the argument list to construct the result lists."))
 ((name . "partition")
  (signature lambda ((procedure? pred) (list? list)) (values list? list?))
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "Partitions the elements of list with predicate pred, and returns two values: the list of in-elements and the list of out-elements. The list is not disordered -- elements occur in the result lists in the same order as they occur in the argument list. The dynamic order in which the various applications of pred are made is not specified. One of the returned lists may share a common tail with the argument list."))
 ((name . "partition!")
  (signature lambda ((procedure? pred) (list? list)) (values list? list?))
  (subsigs (pred (lambda (obj) *)))
  (desc . "filter!, partition!, remove! Linear-update variants of filter, partition and remove. These procedures are allowed, but not required, to alter the cons cells in the argument list to construct the result lists."))
 ((name . "remove")
  (signature lambda ((procedure? pred) (list? list)) list?)
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . " Returns list without the elements that satisfy predicate pred: (lambda (pred list) (filter (lambda (x) (not (pred x))) list)). The list is not disordered -- elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of pred are made is not specified. "))
 ((name . "remove!")
  (signature lambda ((procedure? pred) (list? list)) list?)
  (subsigs (pred (lambda (obj) *)))
  (desc . "filter!, partition!, remove! Linear-update variants of filter, partition and remove. These procedures are allowed, but not required, to alter the cons cells in the argument list to construct the result lists."))
 ((name . "find")
  (signature lambda ((procedure? pred) (list? list)) *)
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "Return the first element of clist that satisfies predicate pred; false if no element does. Note that find has an ambiguity in its lookup semantics -- if find returns #f, you cannot tell (in general) if it found a #f element that satisfied pred, or if it did not find any element at all. In many situations, this ambiguity cannot arise -- either the list being searched is known not to contain any #f elements, or the list is guaranteed to have an element satisfying pred. However, in cases where this ambiguity can arise, you should use find-tail instead of find -- find-tail has no such ambiguity."))
 ((name . "find-tail")
  (signature lambda ((procedure? pred) (list? list)) (or pair? #f))
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "Return the first pair of clist whose car satisfies pred. If no pair does, return false. find-tail can be viewed as a general-predicate variant of the member function.  In the circular-list case, this procedure \"rotates\" the list. Find-tail is essentially drop-while, where the sense of the predicate is inverted: Find-tail searches until it finds an element satisfying the predicate; drop-while searches until it finds an element that doesn't satisfy the predicate."))
 ((name . "take-while")
  (signature lambda ((procedure? pred) (list? list)) list?)
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "take-while, take-while!  Returns the longest initial prefix of clist whose elements all satisfy the predicate pred. Take-while! is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result."))
 ((name . "take-while!")
  (signature lambda ((procedure? pred) (list? list)) list?)
  (subsigs (pred (lambda (obj) *)))
  (desc . "take-while, take-while!  Returns the longest initial prefix of clist whose elements all satisfy the predicate pred. Take-while! is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result."))
 ((name . "drop-while")
  (signature
   case-lambda
   (((procedure? pred) (list? list)) list?)
   (((procedure? pred) (circular-list? list)) circular-list?))
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "Drops the longest initial prefix of clist whose elements all satisfy the predicate pred, and returns the rest of the list. The circular-list case may be viewed as \"rotating\" the list."))
 ((name . "span")
  (signature
   case-lambda
   (((procedure? pred) (list? list)) (values list? list?))
   (((procedure? pred) (circular-list? list)) (values list? circular-list?)))
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "span, span!, break, break!  Span splits the list into the longest initial prefix whose elements all satisfy pred, and the remaining tail. Break inverts the sense of the predicate: the tail commences with the first element of the input list that satisfies the predicate. In other words: span finds the intial span of elements satisfying pred, and break breaks the list at the first element satisfying pred. Span is equivalent to (values (take-while pred clist) (drop-while pred clist)). Span! and break! are the linear-update variants. They are allowed, but not required, to alter the argument list to produce the result. "))
 ((name . "span!")
  (signature lambda ((procedure? pred) (list? list)) (values list? list?))
  (subsigs (pred (lambda (obj) *)))
  (desc . "span, span!, break, break!  Span splits the list into the longest initial prefix whose elements all satisfy pred, and the remaining tail. Break inverts the sense of the predicate: the tail commences with the first element of the input list that satisfies the predicate. In other words: span finds the intial span of elements satisfying pred, and break breaks the list at the first element satisfying pred. Span is equivalent to (values (take-while pred clist) (drop-while pred clist)). Span! and break! are the linear-update variants. They are allowed, but not required, to alter the argument list to produce the result. "))
 ((name . "break")
  (signature
   case-lambda
   (((procedure? pred) (list? list)) (values list? list?))
   (((procedure? pred) (circular-list? list)) (values list? circular-list?)))
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "span, span!, break, break!  Span splits the list into the longest initial prefix whose elements all satisfy pred, and the remaining tail. Break inverts the sense of the predicate: the tail commences with the first element of the input list that satisfies the predicate. In other words: span finds the intial span of elements satisfying pred, and break breaks the list at the first element satisfying pred. Span is equivalent to (values (take-while pred clist) (drop-while pred clist)). Span! and break! are the linear-update variants. They are allowed, but not required, to alter the argument list to produce the result. "))
 ((name . "break!")
  (signature lambda ((procedure? pred) (list? list)) (values list? list?))
  (subsigs (pred (lambda (obj) *)))
  (desc . "span, span!, break, break!  Span splits the list into the longest initial prefix whose elements all satisfy pred, and the remaining tail. Break inverts the sense of the predicate: the tail commences with the first element of the input list that satisfies the predicate. In other words: span finds the intial span of elements satisfying pred, and break breaks the list at the first element satisfying pred. Span is equivalent to (values (take-while pred clist) (drop-while pred clist)). Span! and break! are the linear-update variants. They are allowed, but not required, to alter the argument list to produce the result. "))
 ((name . "any")
  (signature lambda ((procedure? pred) (list? clist1) (list? clist2) ...) *)
  (subsigs (pred (lambda (obj1 obj2 ...) *)))
  (tags pure)
  (desc . "Applies the predicate across the lists, returning true if the predicate returns true on any application. If there are n list arguments clist1 ... clistn, then pred must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, #f means false, and any other value means true). any applies pred to the first elements of the clisti parameters. If this application returns a true value, any immediately returns that value. Otherwise, it iterates, applying pred to the second elements of the clisti parameters, then the third, and so forth. The iteration stops when a true value is produced or one of the lists runs out of values; in the latter case, any returns #f. The application of pred to the last element of the lists is a tail call. Note the difference between find and any -- find returns the element that satisfied the predicate; any returns the true value that the predicate produced. Like every, any's name does not end with a question mark -- this is to indicate that it does not return a simple boolean (#t or #f), but a general value."))
 ((name . "every")
  (signature lambda ((procedure? pred) (list? clist1) (list? clist2) ...) *)
  (subsigs (pred (lambda (obj1 obj2 ...) *)))
  (tags pure)
  (desc . "Applies the predicate across the lists, returning true if the predicate returns true on every application. If there are n list arguments clist1 ... clistn, then pred must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, #f means false, and any other value means true). every applies pred to the first elements of the clisti parameters. If this application returns false, every immediately returns false. Otherwise, it iterates, applying pred to the second elements of the clisti parameters, then the third, and so forth. The iteration stops when a false value is produced or one of the lists runs out of values. In the latter case, every returns the true value produced by its final application of pred. The application of pred to the last element of the lists is a tail call. If one of the clisti has no elements, every simply returns #t. Like any, every's name does not end with a question mark -- this is to indicate that it does not return a simple boolean (#t or #f), but a general value."))
 ((name . "list-index")
  (signature
   lambda
   ((procedure? pred) (list? clist1) (list? clist2) ...)
   (or integer? #f))
  (subsigs (pred (lambda (obj1 obj2 ...) *)))
  (tags pure)
  (desc . "Return the index of the leftmost element that satisfies pred. If there are n list arguments clist1 ... clistn, then pred must be a function taking n arguments and returning a single value, interpreted as a boolean (that is, #f means false, and any other value means true). list-index applies pred to the first elements of the clisti parameters. If this application returns true, list-index immediately returns zero. Otherwise, it iterates, applying pred to the second elements of the clisti parameters, then the third, and so forth. When it finds a tuple of list elements that cause pred to return true, it stops and returns the zero-based index of that position in the lists. The iteration stops when one of the lists runs out of values; in this case, list-index returns #f."))
 ((name . "member")
  (signature
   case-lambda
   ((obj (list? list)) (or #f list?))
   ((obj (list? list) (procedure? =)) (or #f list?)))
  (subsigs (= (lambda (obj1 obj2) *)))
  (tags pure)
  (desc . "member, memq, memv These procedures return the first sublist of list whose car is x, where the sublists of list are the non-empty lists returned by (drop list i) for i less than the length of list. If x does not occur in list, then #f is returned. memq uses eq? to compare x with the elements of list, while memv uses eqv?, and member uses equal?.  member is extended from its R5RS definition to allow the client to pass in an optional equality procedure = used to compare keys. The comparison procedure is used to compare the elements ei of list to the key x in this way: (= x ei) ; list is (E1 ... En). That is, the first argument is always x, and the second argument is one of the list elements. Thus one can reliably find the first element of list that is greater than five with (member 5 list <). Note that fully general list searching may be performed with the find-tail and find procedures."))
 ((name . "memq")
  (signature lambda (obj (list? list)) (or #f list?))
  (tags pure)
  (desc . "member, memq, memv These procedures return the first sublist of list whose car is x, where the sublists of list are the non-empty lists returned by (drop list i) for i less than the length of list. If x does not occur in list, then #f is returned. memq uses eq? to compare x with the elements of list, while memv uses eqv?, and member uses equal?.  member is extended from its R5RS definition to allow the client to pass in an optional equality procedure = used to compare keys. The comparison procedure is used to compare the elements ei of list to the key x in this way: (= x ei) ; list is (E1 ... En). That is, the first argument is always x, and the second argument is one of the list elements. Thus one can reliably find the first element of list that is greater than five with (member 5 list <). Note that fully general list searching may be performed with the find-tail and find procedures."))
 ((name . "memv")
  (signature lambda (obj (list? list)) (or #f list?))
  (tags pure)
  (desc . "member, memq, memv These procedures return the first sublist of list whose car is x, where the sublists of list are the non-empty lists returned by (drop list i) for i less than the length of list. If x does not occur in list, then #f is returned. memq uses eq? to compare x with the elements of list, while memv uses eqv?, and member uses equal?.  member is extended from its R5RS definition to allow the client to pass in an optional equality procedure = used to compare keys. The comparison procedure is used to compare the elements ei of list to the key x in this way: (= x ei) ; list is (E1 ... En). That is, the first argument is always x, and the second argument is one of the list elements. Thus one can reliably find the first element of list that is greater than five with (member 5 list <). Note that fully general list searching may be performed with the find-tail and find procedures."))
 ((name . "delete")
  (signature
   case-lambda
   ((obj (list? list)) list?)
   ((obj (list? list) (procedure? =)) list?))
  (subsigs (= (lambda (obj1 obj2) *)))
  (tags pure)
  (desc . "delete, delete!  delete uses the comparison procedure =, which defaults to equal?, to find all elements of list that are equal to x, and deletes them from list. The dynamic order in which the various applications of = are made is not specified. The list is not disordered -- elements that appear in the result list occur in the same order as they occur in the argument list. The result may share a common tail with the argument list. Note that fully general element deletion can be performed with the remove and remove! procedures.  The comparison procedure is used in this way: (= x ei). That is, x is always the first argument, and a list element is always the second argument. The comparison procedure will be used to compare each element of list exactly once; the order in which it is applied to the various ei is not specified. Thus, one can reliably remove all the numbers greater than five from a list with (delete 5 list <). delete! is the linear-update variant of delete. It is allowed, but not required, to alter the cons cells in its argument list to construct the result."))
 ((name . "delete!")
  (signature
   case-lambda
   ((obj (list? list)) list?)
   ((obj (list? list) (procedure? =)) list?))
  (subsigs (= (lambda (obj1 obj2) *)))
  (desc . "delete, delete!  delete uses the comparison procedure =, which defaults to equal?, to find all elements of list that are equal to x, and deletes them from list. The dynamic order in which the various applications of = are made is not specified. The list is not disordered -- elements that appear in the result list occur in the same order as they occur in the argument list. The result may share a common tail with the argument list. Note that fully general element deletion can be performed with the remove and remove! procedures.  The comparison procedure is used in this way: (= x ei). That is, x is always the first argument, and a list element is always the second argument. The comparison procedure will be used to compare each element of list exactly once; the order in which it is applied to the various ei is not specified. Thus, one can reliably remove all the numbers greater than five from a list with (delete 5 list <). delete! is the linear-update variant of delete. It is allowed, but not required, to alter the cons cells in its argument list to construct the result."))
 ((name . "delete-duplicates")
  (signature
   case-lambda
   (((list? list)) list?)
   (((list? list) (procedure? =)) list?))
  (subsigs (= (lambda (obj1 obj2) *)))
  (tags pure)
  (desc . "delete-duplicates, delete-duplicates!  delete-duplicates removes duplicate elements from the list argument. If there are multiple equal elements in the argument list, the result list only contains the first or leftmost of these elements in the result. The order of these surviving elements is the same as in the original list -- delete-duplicates does not disorder the list (hence it is useful for \"cleaning up\" association lists). The = parameter is used to compare the elements of the list; it defaults to equal?. If x comes before y in list, then the comparison is performed (= x y). The comparison procedure will be used to compare each pair of elements in list no more than once; the order in which it is applied to the various pairs is not specified. Implementations of delete-duplicates are allowed to share common tails between argument and result lists -- for example, if the list argument contains only unique elements, it may simply return exactly this list. Be aware that, in general, delete-duplicates runs in time O(n2) for n-element lists. Uniquifying long lists can be accomplished in O(n lg n) time by sorting the list to bring equal elements together, then using a linear-time algorithm to remove equal elements. Alternatively, one can use algorithms based on element-marking, with linear-time results. delete-duplicates! is the linear-update variant of delete-duplicates; it is allowed, but not required, to alter the cons cells in its argument list to construct the result."))
 ((name . "delete-duplicates!")
  (signature
   case-lambda
   (((list? list)) list?)
   (((list? list) (procedure? =)) list?))
  (subsigs (= (lambda (obj1 obj2) *)))
  (desc . "delete-duplicates, delete-duplicates!  delete-duplicates removes duplicate elements from the list argument. If there are multiple equal elements in the argument list, the result list only contains the first or leftmost of these elements in the result. The order of these surviving elements is the same as in the original list -- delete-duplicates does not disorder the list (hence it is useful for \"cleaning up\" association lists). The = parameter is used to compare the elements of the list; it defaults to equal?. If x comes before y in list, then the comparison is performed (= x y). The comparison procedure will be used to compare each pair of elements in list no more than once; the order in which it is applied to the various pairs is not specified. Implementations of delete-duplicates are allowed to share common tails between argument and result lists -- for example, if the list argument contains only unique elements, it may simply return exactly this list. Be aware that, in general, delete-duplicates runs in time O(n2) for n-element lists. Uniquifying long lists can be accomplished in O(n lg n) time by sorting the list to bring equal elements together, then using a linear-time algorithm to remove equal elements. Alternatively, one can use algorithms based on element-marking, with linear-time results. delete-duplicates! is the linear-update variant of delete-duplicates; it is allowed, but not required, to alter the cons cells in its argument list to construct the result."))
 ((name . "assoc")
  (signature
   case-lambda
   ((obj (list? alist)) (or list? #f))
   ((obj (list? alist) (procedure? =)) (or pair? #f)))
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "assoc, assq, assv alist must be an association list -- a list of pairs. These procedures find the first pair in alist whose car field is key, and returns that pair. If no pair in alist has key as its car, then #f is returned. assq uses eq? to compare key with the car fields of the pairs in alist, while assv uses eqv? and assoc uses equal?.  assoc is extended from its R5RS definition to allow the client to pass in an optional equality procedure = used to compare keys. The comparison procedure is used to compare the elements ei of list to the key parameter in this way: (= key (car ei)) ; list is (E1 ... En). That is, the first argument is always key, and the second argument is one of the list elements. Thus one can reliably find the first entry of alist whose key is greater than five with (assoc 5 alist <). Note that fully general alist searching may be performed with the find-tail and find procedures"))
 ((name . "assq")
  (signature lambda (obj (list? alist)) (or pair? #f))
  (tags pure)
  (desc . "assoc, assq, assv alist must be an association list -- a list of pairs. These procedures find the first pair in alist whose car field is key, and returns that pair. If no pair in alist has key as its car, then #f is returned. assq uses eq? to compare key with the car fields of the pairs in alist, while assv uses eqv? and assoc uses equal?.  assoc is extended from its R5RS definition to allow the client to pass in an optional equality procedure = used to compare keys. The comparison procedure is used to compare the elements ei of list to the key parameter in this way: (= key (car ei)) ; list is (E1 ... En). That is, the first argument is always key, and the second argument is one of the list elements. Thus one can reliably find the first entry of alist whose key is greater than five with (assoc 5 alist <). Note that fully general alist searching may be performed with the find-tail and find procedures"))
 ((name . "assv")
  (signature lambda (obj (list? alist)) (or pair? #f))
  (tags pure)
  (desc . "assoc, assq, assv alist must be an association list -- a list of pairs. These procedures find the first pair in alist whose car field is key, and returns that pair. If no pair in alist has key as its car, then #f is returned. assq uses eq? to compare key with the car fields of the pairs in alist, while assv uses eqv? and assoc uses equal?.  assoc is extended from its R5RS definition to allow the client to pass in an optional equality procedure = used to compare keys. The comparison procedure is used to compare the elements ei of list to the key parameter in this way: (= key (car ei)) ; list is (E1 ... En). That is, the first argument is always key, and the second argument is one of the list elements. Thus one can reliably find the first entry of alist whose key is greater than five with (assoc 5 alist <). Note that fully general alist searching may be performed with the find-tail and find procedures") )
 ((name . "alist-cons")
  (signature lambda (key datum (list? alist)) list?)
  (tags pure)
  (desc . "(lambda (key datum alist) (cons (cons key datum) alist)) Cons a new alist entry mapping key -> datum onto alist."))
 ((name . "alist-copy") (signature lambda ((list? alist)) list?) (tags pure) (desc . "Make a fresh copy of alist. This means copying each pair that forms an association as well as the spine of the list."))
 ((name . "alist-delete")
  (signature
   case-lambda
   ((key (list? alist)) list?)
   ((key (list? alist) (procedure? =)) list?))
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "alist-delete, alist-delete! alist-delete deletes all associations from alist with the given key, using key-comparison procedure =, which defaults to equal?. The dynamic order in which the various applications of = are made is not specified. Return values may share common tails with the alist argument. The alist is not disordered -- elements that appear in the result alist occur in the same order as they occur in the argument alist. The comparison procedure is used to compare the element keys ki of alist's entries to the key parameter in this way: (= key ki). Thus, one can reliably remove all entries of alist whose key is greater than five with (alist-delete 5 alist <). alist-delete! is the linear-update variant of alist-delete. It is allowed, but not required, to alter cons cells from the alist parameter to construct the result."))
 ((name . "alist-delete!")
  (signature
   case-lambda
   ((key (list? alist)) list?)
   ((key (list? alist) (procedure? =)) list?))
  (subsigs (= (lambda (a b) *)))
  (desc . "alist-delete, alist-delete! alist-delete deletes all associations from alist with the given key, using key-comparison procedure =, which defaults to equal?. The dynamic order in which the various applications of = are made is not specified. Return values may share common tails with the alist argument. The alist is not disordered -- elements that appear in the result alist occur in the same order as they occur in the argument alist. The comparison procedure is used to compare the element keys ki of alist's entries to the key parameter in this way: (= key ki). Thus, one can reliably remove all entries of alist whose key is greater than five with (alist-delete 5 alist <). alist-delete! is the linear-update variant of alist-delete. It is allowed, but not required, to alter cons cells from the alist parameter to construct the result."))
 ((name . "lset<=")
  (signature lambda ((procedure? =) (list? list1) ...) boolean?)
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "Returns true iff every listi is a subset of listi+1, using = for the element-equality procedure. List A is a subset of list B if every element in A is equal to some element of B. When performing an element comparison, the = procedure's first argument is an element of A; its second, an element of B."))
 ((name . "lset=")
  (signature lambda ((procedure? =) (list? list1) (list? list2) ...) boolean?)
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "Returns true iff every listi is set-equal to listi+1, using = for the element-equality procedure. \"Set-equal\" simply means that listi is a subset of listi+1, and listi+1 is a subset of listi. The = procedure's first argument is an element of listi; its second is an element of listi+1."))
 ((name . "lset-adjoin")
  (signature lambda ((procedure? =) (list? list) elt1 ...) list?)
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "Adds the elti elements not already in the list parameter to the result list. The result shares a common tail with the list parameter. The new elements are added to the front of the list, but no guarantees are made about their order. The = parameter is an equality procedure used to determine if an elti is already a member of list. Its first argument is an element of list; its second is one of the elti. The list parameter is always a suffix of the result -- even if the list parameter contains repeated elements, these are not reduced."))
 ((name . "lset-union")
  (signature lambda ((procedure? =) (list? list1) ...) list?)
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "Returns the union of the lists, using = for the element-equality procedure. The union of lists A and B is constructed as follows: If A is the empty list, the answer is B (or a copy of B). Otherwise, the result is initialised to be list A (or a copy of A). Proceed through the elements of list B in a left-to-right order. If b is such an element of B, compare every element r of the current result list to b: (= r b). If all comparisons fail, b is consed onto the front of the result. However, there is no guarantee that = will be applied to every pair of arguments from A and B. In particular, if A is eq? to B, the operation may immediately terminate. In the n-ary case, the two-argument list-union operation is simply folded across the argument lists."))
 ((name . "lset-union!")
  (signature lambda ((procedure? =) (list? list1) ...) list?)
  (subsigs (= (lambda (a b) *)))
  (desc . "lset-union!, lset-intersection!, lset-difference!, lset-xor!, lset-diff+intersection!  These are linear-update variants. They are allowed, but not required, to use the cons cells in their first list parameter to construct their answer. lset-union! is permitted to recycle cons cells from any of its list arguments."))
 ((name . "lset-intersection")
  (signature lambda ((procedure? =) (list? list1) (list? list2) ...) list?)
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "Returns the intersection of the lists, using = for the element-equality procedure. The intersection of lists A and B is comprised of every element of A that is = to some element of B: (= a b), for a in A, and b in B. Note this implies that an element which appears in B and multiple times in list A will also appear multiple times in the result. The order in which elements appear in the result is the same as they appear in list1 -- that is, lset-intersection essentially filters list1, without disarranging element order. The result may share a common tail with list1. In the n-ary case, the two-argument list-intersection operation is simply folded across the argument lists. However, the dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely intersect list1 and list2 before proceeding to list3, or it may go about its work in some third order."))
 ((name . "lset-intersection!")
  (signature lambda ((procedure? =) (list? list1) (list? list2) ...) list?)
  (subsigs (= (lambda (a b) *)))
  (desc . "lset-union!, lset-intersection!, lset-difference!, lset-xor!, lset-diff+intersection!  These are linear-update variants. They are allowed, but not required, to use the cons cells in their first list parameter to construct their answer. lset-union! is permitted to recycle cons cells from any of its list arguments."))
 ((name . "lset-difference")
  (signature lambda ((procedure? =) (list? list1) (list? list2) ...) list?)
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "Returns the difference of the lists, using = for the element-equality procedure -- all the elements of list1 that are not = to any element from one of the other listi parameters. The = procedure's first argument is always an element of list1; its second is an element of one of the other listi. Elements that are repeated multiple times in the list1 parameter will occur multiple times in the result. The order in which elements appear in the result is the same as they appear in list1 -- that is, lset-difference essentially filters list1, without disarranging element order. The result may share a common tail with list1. The dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely compute the difference of list1 and list2 before proceeding to list3, or it may go about its work in some third order."))
 ((name . "lset-difference!")
  (signature lambda ((procedure? =) (list? list1) (list? list2) ...) list?)
  (subsigs (= (lambda (a b) *)))
  (desc . "lset-union!, lset-intersection!, lset-difference!, lset-xor!, lset-diff+intersection!  These are linear-update variants. They are allowed, but not required, to use the cons cells in their first list parameter to construct their answer. lset-union! is permitted to recycle cons cells from any of its list arguments."))
 ((name . "lset-xor")
  (signature lambda ((procedure? =) (list? list1) ...) list?)
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . " Returns the exclusive-or of the sets, using = for the element-equality procedure. If there are exactly two lists, this is all the elements that appear in exactly one of the two lists. The operation is associative, and thus extends to the n-ary case -- the elements that appear in an odd number of the lists. The result may share a common tail with any of the listi parameters. More precisely, for two lists A and B, A xor B is a list of every element a of A such that there is no element b of B such that (= a b), and every element b of B such that there is no element a of A such that (= b a). However, an implementation is allowed to assume that = is symmetric -- that is, that (= a b) => (= b a). This means, for example, that if a comparison (= a b) produces true for some a in A and b in B, both a and b may be removed from inclusion in the result. In the n-ary case, the binary-xor operation is simply folded across the lists."))
 ((name . "lset-xor!")
  (signature lambda ((procedure? =) (list? list1) ...) list?)
  (subsigs (= (lambda (a b) *)))
  (desc . "lset-union!, lset-intersection!, lset-difference!, lset-xor!, lset-diff+intersection!  These are linear-update variants. They are allowed, but not required, to use the cons cells in their first list parameter to construct their answer. lset-union! is permitted to recycle cons cells from any of its list arguments."))
 ((name . "lset-diff+intersection")
  (signature
   lambda
   ((procedure? =) (list? list1) (list? list2) ...)
   (values list? list?))
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "Returns two values -- the difference and the intersection of the lists. Is equivalent to (values (lset-difference = list1 list2 ...) (lset-intersection = list1 (lset-union = list2 ...))) but can be implemented more efficiently. The = procedure's first argument is an element of list1; its second is an element of one of the other listi. Either of the answer lists may share a common tail with list1. This operation essentially partitions list1."))
 ((name . "lset-diff+intersection!")
  (signature
   lambda
   ((procedure? =) (list? list1) (list? list2) ...)
   (values list? list?))
  (subsigs (= (lambda (a b) *)))
  (desc . "lset-union!, lset-intersection!, lset-difference!, lset-xor!, lset-diff+intersection!  These are linear-update variants. They are allowed, but not required, to use the cons cells in their first list parameter to construct their answer. lset-union! is permitted to recycle cons cells from any of its list arguments."))
 ((name . "set-car!")
  (signature lambda ((pair? pair) object) undefined)
  (desc . "set-car!, set-cdr! These procedures store object in the car and cdr field of pair, respectively. The value returned is unspecified."))
 ((name . "set-cdr!")
  (signature lambda ((pair? pair) object) undefined)
  (desc . "set-car!, set-cdr! These procedures store object in the car and cdr field of pair, respectively. The value returned is unspecified.")))
