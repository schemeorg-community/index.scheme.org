(((name . "*")
  (signature lambda ((number? z) ...) number?)
  (tags pure)
  (desc . "This procedure returns the product of its arguments."))
 ((name . "+")
  (signature lambda ((number? z) ...) number?)
  (tags pure)
  (desc . "This procedure returns the sum of its arguments."))
 ((name . "-")
  (signature lambda ((number? z) ...) number?)
  (tags pure)
  (desc . "With two or more arguments, this procedure returns the difference of its arguments, associating to the left. With one argument, however, it returns the additive inverse of its argument."))
 ((name . "/")
  (signature lambda ((number? z1) (number? z2) ...) number?)
  (tags pure)
  (desc . "With two or more arguments, this procedure returns the quotient of its arguments, associating to the left. With one argument, however, it returns multiplicative inverse of its argument. It is an error if any argument of / other than the first is an exact zero. If the first argument is an exact zero, an implementation may return an exact zero unless one of the other arguments is a NaN."))
 ((name . "<")
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if its arguments are monotonically increasing, and #f otherwise. If any of the arguments are +nan.0, predicate returns #f. It does not distinguish between inexact zero and inexact negative zero. The predicate is transitive. Note: While it is not an error to compare inexact numbers using this predicate, the results are unreliable because a small inaccuracy can affect the result. When in doubt, consult a numerical analyst."))
 ((name . "<=")
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if its arguments are monotonically non-decreasing, and #f otherwise. If any of the arguments are +nan.0, predicate returns #f. It does not distinguish between inexact zero and inexact negative zero. The predicate is transitive. Note: While it is not an error to compare inexact numbers using this predicate, the results are unreliable because a small inaccuracy can affect the result. When in doubt, consult a numerical analyst."))
 ((name . "=")
  (signature lambda ((number? z1) (number? z2) (number? z3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if its arguments are equal, and #f otherwise. If any of the arguments are +nan.0, the predicate return #f. It does not distinguish between inexact zero and inexact negative zero. This predicate is transitive. Note: While it is not an error to compare inexact numbers using this predicate, the results are unreliable because a small inaccuracy can affect the result; this is especially true of =. When in doubt, consult a numerical analyst."))
 ((name . ">")
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if its arguments are monotonically decreasing, and #f otherwise. If any of the arguments are +nan.0, predicate returns #f. It does not distinguish between inexact zero and inexact negative zero. The predicate is transitive. Note: While it is not an error to compare inexact numbers using this predicate, the results are unreliable because a small inaccuracy can affect the result. When in doubt, consult a numerical analyst."))
 ((name . ">=")
  (signature lambda ((real? x1) (real? x2) (real? x3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if its arguments are monotonically non-increasing, and #f otherwise. If any of the arguments are +nan.0, predicate returns #f. It does not distinguish between inexact zero and inexact negative zero. The predicate is transitive. Note: While it is not an error to compare inexact numbers using this predicate, the results are unreliable because a small inaccuracy can affect the result. When in doubt, consult a numerical analyst."))
 ((name . "abs") (signature lambda ((real? x)) number?) (tags pure) (desc . "The abs procedure returns the absolute value of its argument."))
 ((name . "and") (signature syntax-rules () ((_ test1 ...))) (desc . "Semantics: The test expressions are evaluated from left to right, and if any expression evaluates to #f (see section 6.3), then #f is returned. Any remaining expressions are not evaluated. If all the expressions evaluate to true values, the values of the last expression are returned. If there are no expressions, then #t is returned."))
 ((name . "append")
  (signature case-lambda (((list? list) ...) list?) (((list? list) ... obj) *))
  (tags pure)
  (desc . "Returns a list consisting of the elements of the first list followed by the elements of the other list s. If there are no arguments, the empty list is returned. If there is exactly one argument, it is returned. Otherwise the resulting list is always newly allocated, except that it shares structure with the last argument. An improper list results if the last argument is not a proper list."))
 ((name . "apply")
  (signature lambda ((procedure? proc) arg1 ... (list? args)) *)
  (tags pure)
  (desc . "The apply procedure calls proc with the elements of the list"))
 ((name . "assoc")
  (signature
   case-lambda
   ((obj (list? alist)) (or pair? #f))
   ((obj (list? alist) (procedure? =)) (or pair? #f)))
  (subsigs (= (lambda (a b) *)))
  (tags pure)
  (desc . "It is an error if alist (for \"association list\") is not a list of pairs. This procedure finds the first pair in alist whose car field is obj, and returns that pair. If no pair in alist has obj as its car, then #f (not the empty list) is returned. The assoc procedure uses compare if given and equal? otherwise. Rationale: Although they are often used as predicates, memq, memv, member, assq, assv, and assoc do not have question marks in their names because they return potentially useful values rather than just #t or #f."))
 ((name . "assq")
  (signature lambda (obj (list? alist)) (or pair? #f))
  (tags pure)
  (desc . "It is an error if alist (for \"association list\") is not a list of pairs. This procedure finds the first pair in alist whose car field is obj, and returns that pair. If no pair in alist has obj as its car, then #f (not the empty list) is returned. The assq procedure uses eq? to compare obj with the car fields of the pairs in alist. Rationale: Although they are often used as predicates, memq, memv, member, assq, assv, and assoc do not have question marks in their names because they return potentially useful values rather than just #t or #f."))
 ((name . "assv")
  (signature lambda (obj (list? alist)) (or pair? #f))
  (tags pure)
  (desc . "It is an error if alist (for \"association list\") is not a list of pairs. This procedure finds the first pair in alist whose car field is obj, and returns that pair. If no pair in alist has obj as its car, then #f (not the empty list) is returned. The assv procedure uses eqv? to compare obj with the car fields of the pairs in alist. Rationale: Although they are often used as predicates, memq, memv, member, assq, assv, and assoc do not have question marks in their names because they return potentially useful values rather than just #t or #f."))
 ((name . "begin")
  (signature syntax-rules () ((_ expression-or-definition ...)))
  (desc . "This form of begin can be used as an ordinary expression. The expressions are evaluated sequentially from left to right, and the values of the last expression are returned. This expression type is used to sequence side effects such as assignments or input and output. Note that there is another form of begin used as a library declaration: see section 5.6.1."))
 ((name . "binary-port?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes port?))
 ((name . "boolean=?")
  (signature
   lambda
   ((boolean? boolean1) (boolean? boolean2) (boolean? boolean3) ...)
   boolean?)
  (tags pure)
  (desc . "Returns #t if all the arguments are booleans and all are #t or all are #f."))
 ((name . "boolean?") (signature lambda (obj) boolean?) (tags pure predicate) (desc . "The boolean? predicate returns #t if obj is either #t or #f and returns #f otherwise."))
 ((name . "bytevector")
  (signature lambda ((integer? byte) ...) bytevector?)
  (tags pure)
  (desc . "Returns a newly allocated bytevector containing its arguments."))
 ((name . "bytevector-append")
  (signature lambda ((bytevector? bytevector) ...) bytevector?)
  (tags pure)
  (desc . "Returns a newly allocated bytevector whose elements are the concatenation of the elements in the given bytevectors."))
 ((name . "bytevector-copy")
  (signature
   case-lambda
   (((bytevector? bytevector)) bytevector?)
   (((bytevector? bytevector) (integer? start)) bytevector?)
   (((bytevector? bytevector) (integer? start) (integer? end)) bytevector?))
  (tags pure)
  (desc . "Returns a newly allocated bytevector containing the bytes in bytevector between start and end."))
 ((name . "bytevector-copy!")
  (signature
   case-lambda
   (((bytevector? to) (integer? at) (bytevector? from)) undefined)
   (((bytevector? to) (integer? at) (bytevector? from) (integer? start))
    undefined)
   (((bytevector? to)
     (integer? at)
     (bytevector? from)
     (integer? start)
     (integer? end))
    undefined))
  (desc . "Copies the bytes of bytevector from between start and end to bytevector to, starting at at. The order in which bytes are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary bytevector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances. Note: This procedure appears in R6RS, but places the source before the destination, contrary to other such procedures in Scheme."))
 ((name . "bytevector-length")
  (signature lambda ((bytevector? bytevector)) integer?)
  (tags pure)
  (desc . "Returns the length of bytevector in bytes as an exact integer."))
 ((name . "bytevector-u8-ref")
  (signature lambda ((bytevector? bytevector) (integer? k)) integer?)
  (tags pure)
  (desc . "It is an error if k is not a valid index of bytevector. Returns the kth byte of bytevector."))
 ((name . "bytevector-u8-set!")
  (signature
   lambda
   ((bytevector? bytevector) (integer? k) (integer? byte))
   undefined)
  (desc . "It is an error if k is not a valid index of bytevector. Stores byte as the kth byte of bytevector."))
 ((name . "bytevector?")
  (signature lambda (obj) boolean?)
  (tags pure predicate))
 ((name . "caar") (signature lambda ((pair? pair)) *) (tags pure) (desc . "This procedure is composition of car and car"))
 ((name . "cadr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "This procedure is composition of car and cdr"))
 ((name . "call-with-current-continuation")
  (signature lambda ((procedure? proc)) *)
  (subsigs (proc (lambda ((procedure? k)) *)))
  (desc . "It is an error if proc does not accept one argument. The procedure call-with-current-continuation (or its equivalent abbreviation call/cc) packages the current continuation (see the rationale below) as an \"escape procedure\" and passes it as an argument to proc. The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in ect at that later time and will instead use the continuation that was in effect when the escape procedure was created. Calling the escape procedure will cause the invocation of before and after thunks installed using dynamic-wind. The escape procedure accepts the same number of arguments as the continuation to the original call to call-with-current-continuation. Most continuations take only one value. Continuations created by the call-with-values procedure (including the initialization expressions of define-values, let-values, and let*-values expressions), take the number of values that the consumer expects. The continuations of all non-final expressions within a sequence of expressions, such as in lambda, case-lambda, begin, let, let*, letrec, letrec*, let-values, let*-values, let-syntax, letrec-syntax, parameterize, guard, case, cond, when, and unless expressions, take an arbitrary number of values because they discard the values passed to them in any event. The ect of passing no values or more than one value to continuations that were not created in one of these ways is unspecified. The escape procedure that is passed to proc has unlimited extent just like any other procedure in Scheme. It can be stored in variables or data structures and can be called as many times as desired. However, like the raise and error procedures, it never returns to its caller. Rationale: A common use of call-with-current-continuation is for structured, non-local exits from loops or procedure bodies, but in fact call-with-current-continuation is useful for implementing a wide variety of advanced control structures. In fact, raise and guard provide a more structured mechanism for nonlocal exits. Whenever a Scheme expression is evaluated there is a continuation wanting the result of the expression. The continuation represents an entire (default) future for the computation. If the expression is evaluated at the REPL, for example, then the continuation might take the result, print it on the screen, prompt for the next input, evaluate it, and so on forever. Most of the time the continuation includes actions specified by user code, as in a continuation that will take the result, multiply it by the value stored in a local variable, add seven, and give the answer to the REPL's continuation to be printed. Normally these ubiquitous continuations are hidden behind the scenes and programmers do not think much about them. On rare occasions, however, a programmer needs to deal with continuations explicitly. The call-with-current-continuation procedure allows Scheme programmers to do that by creating a procedure that acts just like the current continuation."))
 ((name . "call-with-port")
  (signature lambda ((port? port) (procedure? proc)) *)
  (subsigs (proc (lambda ((port? port)) *)))
  (desc . "It is an error if proc does not accept one argument. The call-with-port procedure calls proc with port as an argument. If proc returns, then the port is closed automatically and the values yielded by the proc are returned. If proc does not return, then the port must not be closed automatically unless it is possible to prove that the port will never again be used for a read or write operation. Rationale: Because Schemeâ€™s escape procedures have unlimited extent, it is possible to escape from the current continuation but later to resume it. If implementations were permitted to close the port on any escape from the current continuation, then it would be impossible to write portable code using both call-with-current-continuation and call-with-port."))
 ((name . "call-with-values")
  (signature lambda ((procedure? producer) (procedure? consumer)) *)
  (subsigs (producer (lambda () *)) (consumer (lambda (obj ...) *)))
  (tags pure)
  (desc . "Calls its producer argument with no arguments and a continuation that, when passed some values, calls the consumer procedure with those values as arguments. The continuation for the call to consumer is the continuation of the call to call-with-values."))
 ((name . "call/cc")
  (signature lambda ((procedure? proc)) *)
  (subsigs (proc (lambda ((procedure? k)) *)))
  (desc . "It is an error if proc does not accept one argument. The procedure call-with-current-continuation (or its equivalent abbreviation call/cc) packages the current continuation (see the rationale below) as an \"escape procedure\" and passes it as an argument to proc. The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in ect at that later time and will instead use the continuation that was in effect when the escape procedure was created. Calling the escape procedure will cause the invocation of before and after thunks installed using dynamic-wind. The escape procedure accepts the same number of arguments as the continuation to the original call to call-with-current-continuation. Most continuations take only one value. Continuations created by the call-with-values procedure (including the initialization expressions of define-values, let-values, and let*-values expressions), take the number of values that the consumer expects. The continuations of all non-final expressions within a sequence of expressions, such as in lambda, case-lambda, begin, let, let*, letrec, letrec*, let-values, let*-values, let-syntax, letrec-syntax, parameterize, guard, case, cond, when, and unless expressions, take an arbitrary number of values because they discard the values passed to them in any event. The ect of passing no values or more than one value to continuations that were not created in one of these ways is unspecified. The escape procedure that is passed to proc has unlimited extent just like any other procedure in Scheme. It can be stored in variables or data structures and can be called as many times as desired. However, like the raise and error procedures, it never returns to its caller. Rationale: A common use of call-with-current-continuation is for structured, non-local exits from loops or procedure bodies, but in fact call-with-current-continuation is useful for implementing a wide variety of advanced control structures. In fact, raise and guard provide a more structured mechanism for nonlocal exits. Whenever a Scheme expression is evaluated there is a continuation wanting the result of the expression. The continuation represents an entire (default) future for the computation. If the expression is evaluated at the REPL, for example, then the continuation might take the result, print it on the screen, prompt for the next input, evaluate it, and so on forever. Most of the time the continuation includes actions specified by user code, as in a continuation that will take the result, multiply it by the value stored in a local variable, add seven, and give the answer to the REPL's continuation to be printed. Normally these ubiquitous continuations are hidden behind the scenes and programmers do not think much about them. On rare occasions, however, a programmer needs to deal with continuations explicitly. The call-with-current-continuation procedure allows Scheme programmers to do that by creating a procedure that acts just like the current continuation."))
 ((name . "car") (signature lambda ((pair? pair)) *) (tags pure) (desc . "Returns the contents of the car field of pair . Note that it is an error to take the car of the empty list."))
 ((name . "case")
  (signature syntax-rules (=> else) ((_ key clause1 clause2 ...)))
  (subsigs
   (clause
    (pattern
     ((datum1 ...) expression1 expression2 ...)
     ((datum1 ...) => expression)
     (else expression1 expression2 ...)
     (else => expression))))
  (desc . "A case expression is evaluated as follows. Key is evaluated and its result is compared against each datum. If the result of evaluating key is the same (in the sense of eqv?; see section 6.1) to a datum, then the expressions in the corresponding clause are evaluated in order and the results of the last expression in the clause are returned as the results of the case expression. If the result of evaluating key is different from every datum, then if there is an else clause, its expressions are evaluated and the results of the last are the results of the case expression; otherwise the result of the case expression is unspecified. If the selected clause or else clause uses the => alternate form, then the expression is evaluated. It is an error if its value is not a procedure accepting one argument. This procedure is then called on the value of the key and the values returned by this procedure are returned by the case expression."))
 ((name . "cdar")
  (signature lambda ((pair? pair)) *)
  (tags pure)
  (desc . "This procedure is composition of cdr and car"))
 ((name . "cddr")
  (signature lambda ((pair? pair)) *)
  (tags pure)
  (desc . "This procedure is composition of cdr and cdr"))
 ((name . "cdr")
  (signature lambda ((pair? pair)) *)
  (tags pure)
  (desc . "Returns the contents of the cdr field of pair . Note that it is an error to take the cdr of the empty list."))
 ((name . "ceiling")
  (signature lambda ((real? x)) real?)
  (tags pure)
  (desc . "The ceiling procedure returns the smallest integer not smaller than x. Note: If the argument is inexact, then the result will also be inexact. If an exact value is needed, the result can be passed to the exact procedure. If the argument is infinite or a NaN, then it is returned."))
 ((name . "char->integer")
  (signature lambda ((char? char)) integer?)
  (tags pure)
  (desc . "Given a Unicode character, char->integer returns an exact integer between 0 and #xD7FF or between #xE000 and #x10FFFF which is equal to the Unicode scalar value of that character. Given a non-Unicode character, it returns an exact integer greater than #x10FFFF. This is true independent of whether the implementation uses the Unicode representation internally. Given an exact integer that is the value returned by a character when char->integer is applied to it, integer->char returns that character."))
 ((name . "char-ready?")
  (signature case-lambda (() boolean?) (((input-port? port)) boolean?))
  (desc . "Returns #t if a character is ready on the textual input port and returns #f otherwise. If char-ready returns #t then the next read-char operation on the given port is guaranteed not to hang. If the port is at end of file then char-ready? returns #t. Rationale: The char-ready? procedure exists to make it possible for a program to accept characters from interactive ports without getting stuck waiting for input. Any input editors associated with such ports must ensure that characters whose existence has been asserted by char-ready? cannot be removed from the input. If char-ready? were to return #f at end of file, a port at end of file would be indistinguishable from an interactive port that has no ready characters."))
 ((name . "char<=?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if the results of passing their arguments to char->integer are monotonically non-decreasing. This predicate is required to be transitive."))
 ((name . "char<?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if the results of passing their arguments to char->integer are monotonically increasing. This predicate is required to be transitive."))
 ((name . "char=?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if the results of passing their arguments to char->integer are equal. This predicate is required to be transitive."))
 ((name . "char>=?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if the results of passing their arguments to char->integer are monotonically non-increasing. This predicate is required to be transitive."))
 ((name . "char>?")
  (signature lambda ((char? char1) (char? char2) (char? char3) ...) boolean?)
  (tags pure)
  (desc . "This procedure returns #t if the results of passing their arguments to char->integer are monotonically decreasing. This predicate is required to be transitive."))
 ((name . "char?")
  (signature lambda (obj) boolean?)
  (tags pure predicate))
 ((name . "close-input-port")
  (signature lambda ((input-port? port)) undefined)
  (desc . "Closes the resource associated with port, rendering the port incapable of delivering data. It is an error to apply the procedure to a port which is not an input port. Scheme implementations may provide ports which are simultaneously input and output ports, such as sockets; the close-input-port and close-output-port procedures can then be used to close the input and output sides of the port independently. The routine has no effect if the port has already been closed."))
 ((name . "close-output-port")
  (signature lambda ((output-port? port)) undefined)
  (desc . "Closes the resource associated with port, rendering the port incapable of accepting data. It is an error to apply the procedure to a port which is not an output port. Scheme implementations may provide ports which are simultaneously input and output ports, such as sockets; the close-input-port and close-output-port procedures can then be used to close the input and output sides of the port independently. The routine has no effect if the port has already been closed."))
 ((name . "close-port") 
  (signature lambda ((port? port)) undefined)
  (desc . "Closes the resource associated with port, rendering the port incapable of delivering or accepting data. This routine has no effect if the port has already been closed."))
 ((name . "complex?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes number?)
  (desc . "This numerical type predicate can be applied to any kind of argument, including non-numbers. Returns #t if the object is of the named type, and otherwise it returns #f. Note: The behavior of this type predicate on inexact numbers is unreliable, since any inaccuracy might affect the result. Note: In many implementations the complex? procedure will be the same as number?, but unusual implementations may represent some irrational numbers exactly or may extend the number system to support some kind of non-complex numbers."))
 ((name . "cond")
  (signature syntax-rules (else =>) ((_ clause1 clause2 ...)))
  (subsigs
   (clause
    (pattern
     (test expression1 ...)
     (test => receiver)
     (else expression1 expression2 ...)))
   (receiver (value procedure?)))
  (desc . "A cond expression is evaluated by evaluating the test expressions of successive clauses in order until one of them evaluates to a true value (see section 6.3). When a test evaluates to a true value, the remaining expressions in its clause are evaluated in order, and the results of the last expression in the clause are returned as the results of the entire cond expression. If the selected clause contains only the test and no expressions, then the value of the test is returned as the result. If the selected clause uses the => alternate form, then the expression is evaluated. It is an error if its value is not a procedure that accepts one argument. This procedure is then called on the value of the test and the values returned by this procedure are returned by the cond expression. If all tests evaluate to #f, and there is no else clause, then the result of the conditional expression is unspecified; if there is an else clause, then its expressions are evaluated in order, and the values of the last one are returned."))
 ((name . "cons")
  (signature lambda (obj1 obj2) pair?)
  (tags pure)
  (desc . "Returns a newly allocated pair whose car is obj1 and whose cdr is obj2. The pair is guaranteed to be different(sense of eqv?) from every existing object."))
 ((name . "current-error-port")
  (signature lambda () output-port?)
  (tags parameter))
 ((name . "current-input-port")
  (signature lambda () input-port?)
  (tags parameter))
 ((name . "current-output-port")
  (signature lambda () output-port?)
  (tags parameter))
 ((name . "define")
  (signature
   syntax-rules
   ()
   ((_ variable expression))
   ((_ (variable parameter1 ...) body))
   ((_ (variable parameter1 ... . parameter) body)))
  (desc . "At the outermost level of a program, a definition (define variable expression) has essentially the same effect as the assignment expression (set! variable expression) if variable is bound to a non-syntax value. However, if variable is not bound, or is a syntactic keyword, then the definition will bind variable to a new location before performing the assignment, whereas it would be an error to perform a set! on an unbound variable. Definitions can occur at the beginning of a body (that is, the body of a lambda, let, let*, letrec, letrec*, let-values, let*-values, let-syntax, letrec-syntax, parameterize, guard, or case-lambda). Note that such a body might not be apparent until after expansion of other syntax. Such definitions are known as internal definitions as opposed to the global definitions described above. The variables defined by internal definitions are local to the body That is, variable is bound rather than assigned, and the region of the binding is the entire body. An expanded body containing internal definitions can always be converted into a completely equivalent letrec* expression. Just as for the equivalent letrec* expression, it is an error if it is not possible to evaluate each expression of every internal definition in a body without assigning or referring to the value of the corresponding variable or the variable of any of the definitions that follow it in body. It is an error to define the same identifier more than once in the same body. Wherever an internal definition can occur, (begin definition1 ...) is equivalent to the sequence of definitions that form the body of the begin."))
 ((name . "define-syntax")
  (signature syntax-rules () ((_ keyword transformer-spec)))
  (subsigs (transformer-spec (value transformer-spec)))
  (desc . "If the define-syntax occurs at the outermost level, then the global syntactic environment is extended by binding the keyword to the specified transformer, but previous expansions of any global binding for keyword remain unchanged. Otherwise, it is an internal syntax definition, and is local to the body in which it is defined. Any use of a syntax keyword before its corresponding definition is an error. In particular, a use that precedes an inner definition will not apply an outer definition. Macros can expand into definitions in any context that permits them. However, it is an error for a definition to define an identifier whose binding has to be known in order to determine the meaning of the definition itself, or of any preceding definition that belongs to the same group of internal definitions. Similarly, it is an error for an internal definition to define an identifier whose binding has to be known in order to determine the boundary between the internal definitions and the expressions of the body it belongs to."))
 ((name . "define-values")
  (signature syntax-rules () ((_ formals expression)))
  (subsigs
   (formals
    (pattern
     (variable1 ...)
     variable
     (variable1 ... variable_n . variable_n+1))))
  (desc . "Another kind of definition is provided by define-values, which creates multiple definitions from a single expression returning multiple values. It is allowed wherever define is allowed. It is an error if a variable appears more than once in the set of formals.  Semantics: Expression is evaluated, and the formals are bound to the return values in the same way that the formals in a lambda expression are matched to the arguments in a procedure call.")) 
 ((name . "denominator")
  (signature lambda ((rational? q)) integer?)
  (tags pure)
  (desc . "This procedure returns the denominator of its argument; the result is computed as if the argument was represented as a fraction in lowest terms. The denominator is always positive. The denominator of 0 is defined to be 1."))
 ((name . "do")
  (signature
   syntax-rules
   ()
   ((_ (variable-decl1 ...) (test expression ...) command ...)))
  (subsigs (variable-decl (pattern (variable init step) (variable init))))
  (desc . "A do expression is an iteration construct. It specifies a set of variables to be bound, how they are to be initialized at the start, and how they are to be updated on each iteration. When a termination condition is met, the loop exits after evaluating the expressions. A do expression is evaluated as follows: The init expressions are evaluated (in some unspecified order), the variables are bound to fresh locations, the results of the init expressions are stored in the bindings of the variables, and then the iteration phase begins. Each iteration begins by evaluating test; if the result is false (see section 6.3), then the command expressions are evaluated in order for effect, the step expressions are evaluated in some unspecified order, the variables are bound to fresh locations, the results of the steps are stored in the bindings of the variables, and the next iteration begins. If test evaluates to a true value, then the expressions are evaluated from left to right and the values of the last expression are returned. If no expressions are present, then the value of the do expression is unspecified. The region of the binding of a variable consists of the entire do expression except for the inits. It is an error for a variable to appear more than once in the list of do variables. A step can be omitted, in which case the effect is the same as if (variable init variable) had been written instead of (variable init)."))
 ((name . "dynamic-wind")
  (signature
   lambda
   ((procedure? before) (procedure? thunk) (procedure? after))
   *)
  (subsigs
   (before (lambda () undefined))
   (thunk (lambda () *))
   (after (lambda () undefined)))
  (desc . "Calls thunk without arguments, returning the result(s) of this call. Before and after are called, also without arguments, as required by the following rules. Note that, in the absence of calls to continuations captured using call-with-current-continuation, the three arguments are called once each, in order. Before is called whenever execution enters the dynamic extent of the call to thunk and after is called whenever it exits that dynamic extent. The dynamic extent of a procedure call is the period between when the call is initiated and when it returns. The before and after thunks are called in the same dynamic environment as the call to dynamic-wind. In Scheme, because of call-with-current-continuation, the dynamic extent of a call is not always a single, connected time period. It is defined as follows: 1) The dynamic extent is entered when execution of the body of the called procedure begins; 2) The dynamic extent is also entered when execution is not within the dynamic extent and a continuation is invoked that was captured (using call-with-current-continuation) during the dynamic extent; 3) It is exited when the called procedure returns; 4) It is also exited when execution is within the dynamic extent and a continuation is invoked that was captured while not within the dynamic extent. If a second call to dynamic-wind occurs within the dynamic extent of the call to thunk and then a continuation is invoked in such a way that the after s from these two invocations of dynamic-wind are both to be called, then the after associated with the second (inner) call to dynamic-wind is called first. If a second call to dynamic-wind occurs within the dynamic extent of the call to thunk and then a continuation is invoked in such a way that the befores from these two invocations of dynamic-wind are both to be called, then the before associated with the first (outer) call to dynamic-wind is called first. If invoking a continuation requires calling the before from one call to dynamic-wind and the after from another, then the after is called first. The ect of using a captured continuation to enter or exit the dynamic extent of a call to before or after is unspecified."))
 ((name . "eof-object") (signature lambda () eof-object?) (tags pure) (desc . "Returns an end-of-file object, not necessarily unique."))
 ((name . "eof-object?")
  (signature lambda (obj) boolean?)
  (tags pure predicate))
 ((name . "eq?") (signature lambda (obj1 obj2) boolean?) (tags pure) (desc . "The eq? procedure is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?. It must always return #f when eqv? also would, but may return #f in some cases where eqv? would return #t. On symbols, booleans, the empty list, pairs, and records, and also on non-empty strings, vectors, and bytevectors, eq? and eqv? are guaranteed to have the same behavior. On procedures, eq? must return true if the arguments' location tags are equal. On numbers and characters, eq?'s behavior is implementation-dependent, but it will always return either true or false. On empty strings, empty vectors, and empty bytevectors, eq? may also behave differently from eqv?."))
 ((name . "equal?") (signature lambda (obj1 obj2) boolean?) (tags pure) (desc . "The equal? procedure, when applied to pairs, vectors, strings and bytevectors, recursively compares them, returning #t when the unfoldings of its arguments into (possibly infinite) trees are equal (in the sense of equal? ) as ordered trees, and #f otherwise. It returns the same as eqv? when applied to booleans, symbols, numbers, characters, ports, procedures, and the empty list. If two objects are eqv? , they must be equal? as well. In all other cases, equal? may return either #t or #f. Note: A rule of thumb is that objects are generally equal? if they print the same."))
 ((name . "eqv?") 
  (signature lambda (obj1 obj2) boolean?)
  (tags pure)
  (desc . "The eqv? procedure defines a useful equivalence relation on objects. Briefly, it returns #t if obj1 and obj2 are normally regarded as the same object. This relation is left slightly open to interpretation, but the following partial specification of eqv? holds for all implementations of Scheme. The eqv? procedure returns #t if: obj1 and obj2 are both #t or both #f; obj1 and obj2 are both symbols and are the same symbol according to the symbol=? procedure (section 6.5); obj1 and obj2 are both exact numbers and are numerically equal (in the sense of =); obj1 and obj2 are both inexact numbers such that they are numerically equal (in the sense of =) and they yield the same results (in the sense of eqv?) when passed as arguments to any other procedure that can be defined as a finite composition of Scheme's standard arithmetic procedures, provided it does not result in a NaN value; obj1 and obj2 are both characters and are the same character according to the char=? procedure (section 6.6); obj1 and obj2 are both the empty list; obj1 and obj2 are pairs, vectors, bytevectors, records, or strings that denote the same location in the store (section 3.4); obj1 and obj2 are procedures whose location tags are equal (section 4.1.4). The eqv? procedure returns #f if: obj1 and obj2 are of different types (section 3.2); one of obj1 and obj2 is #t but the other is #f; obj1 and obj2 are symbols but are not the same symbol according to the symbol=? procedure (section 6.5); one of obj1 and obj2 is an exact number but the other is an inexact number; obj1 and obj2 are both exact numbers and are numerically unequal (in the sense of =); obj1 and obj2 are both inexact numbers such that either they are numerically unequal (in the sense of =), or they do not yield the same results (in the sense of eqv?) when passed as arguments to any other procedure that can be defined as a finite composition of Scheme's standard arithmetic procedures, provided it does not result in a NaN value. As an exception, the behavior of eqv? is unspecified when both obj1 and obj2 are NaN; obj1 and obj2 are characters for which the char=? procedure returns #f; one of obj1 and obj2 is the empty list but the other is not; obj1 and obj2 are pairs, vectors, bytevectors, records, or strings that denote distinct locations; obj1 and obj2 are procedures that would behave differently (return different values or have different side effects) for some arguments."))
 ((name . "error-object-irritants")
  (signature lambda ((error-object? error-object)) list?)
  (tags pure)
  (desc . "Returns a list of the irritants encapsulated by error-object."))
 ((name . "error-object-message")
  (signature lambda ((error-object? error-object)) string?)
  (tags pure)
  (desc . "Returns the message encapsulated by error-object."))
 ((name . "error-object?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is an object created by error or one of an implementation-defined set of objects. Otherwise, it returns #f. The objects used to signal errors, including those which satisfy the predicates file-error? and read-error?, may or may not satisfy error-object?."))
 ((name . "even?")
  (signature lambda ((integer? n)) boolean?)
  (tags pure predicate))
 ((name . "exact")
  (signature lambda ((number? z)) exact?) (tags pure)
  (desc . "The procedure exact returns an exact representation of z. The value returned is the exact number that is numerically closest to the argument. For exact arguments, the result is the same as the argument. For inexact nonintegral real arguments, the implementation may return a rational approximation, or may report an implementation violation. For inexact complex arguments, the result is a complex number whose real and imaginary parts are the result of applying exact to the real and imaginary parts of the argument, respectively. If an inexact argument has no reasonably close exact equivalent, (in the sense of =), then a violation of an implementation restriction may be reported."))
 ((name . "exact-integer-sqrt")
  (signature lambda ((integer? k)) (values integer? integer?))
  (tags pure)
  (desc . "Returns two non-negative exact integers s and r where k = s^2 + r and k < (s + 1)^2."))
 ((name . "exact-integer?")
  (signature lambda ((number? z)) boolean?)
  (tags pure)
  (supertypes exact? integer?)
  (desc . "Returns #t if z is both exact and an integer; otherwise returns #f."))
 ((name . "exact?")
  (signature lambda ((number? z)) boolean?)
  (tags pure)
  (supertypes number?)
  (desc . "This numerical predicate provides tests for the exactness of a quantity. For any Scheme number, precisely one of exact? or inexact? predicates is true."))
 ((name . "expt")
  (signature lambda ((number? z1) (number? z2)) number?)
  (tags pure)
  (desc . "Returns z1 raised to the power z2."))
 ((name . "features") 
  (signature lambda () list?)
  (tags pure)
  (desc . "Returns a list of the feature identifiers which cond-expand treats as true. It is an error to modify this list."))
 ((name . "file-error?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Error type predicate. Returns #t if obj is an object raised by the inability to open an input or output port on a file. Otherwise, it returns #f."))
 ((name . "floor")
  (signature lambda ((real? x)) integer?)
  (tags pure)
  (desc . "The floor procedure returns the largest integer not larger than x. Note: If the argument is inexact, then the result will also be inexact. If an exact value is needed, the result can be passed to the exact procedure. If the argument is infinite or a NaN, then it is returned."))
 ((name . "floor-quotient")
  (signature lambda ((integer? n1) (integer? n2)) integer?)
  (tags pure)
  (desc . "This procedure implements number-theoretic (integer) division. It is an error if n2 is zero. The procedure computes a quotient nq and remainder nr such that n1 = n2 * nq + nr."))
 ((name . "floor-remainder")
  (signature lambda ((integer? n1) (integer? n2)) integer?)
  (tags pure)
  (desc . "This procedure implements number-theoretic (integer) division. It is an error if n2 is zero. The procedure computes a quotient nq and remainder nr such that n1 = n2 * nq + nr."))
 ((name . "floor/")
  (signature lambda ((integer? n1) (integer? n2)) (values integer? integer?))
  (tags pure)
  (desc . "This procedure implements number-theoretic (integer) division. It is an error if n2 is zero. The procedure computes a quotient nq and remainder nr such that n1 = n2 * nq + nr."))
 ((name . "flush-output-port")
  (signature case-lambda (() undefined) (((output-port? port)) undefined))
  (desc . "Flushes any buffered output from the buffer of output-port to the underlying file or device and returns an unspecified value."))
 ((name . "for-each")
  (signature
   lambda
   ((procedure? proc) (list? list1) (list? list2) ...)
   undefined)
  (subsigs (proc (lambda (obj1 obj2 ...) undefined)))
  (desc . "It is an error if proc does not accept as many arguments as there are lists. The arguments to for-each are like the arguments to map, but for-each calls proc for its side ects rather than for its values. Unlike map, for-each is guaranteed to call proc on the elements of the lists in order from the first element( s) to the last, and the value returned by for-each is unspecified. If more than one list is given and not all lists have the same length, for-each terminates when the shortest list runs out. It is an error for proc to mutate any of the lists."))
 ((name . "gcd")
  (signature lambda ((integer? n) ...) integer?)
  (tags pure)
  (desc . "This procedure returns the greatest common divisor of its arguments. The result is always non-negative."))
 ((name . "get-output-bytevector")
  (signature lambda ((output-port? port)) bytevector?)
  (desc . "It is an error if port was not created with open-output-bytevector. Returns a bytevector consisting of the bytes that have been output to the port so far in the order they were output."))
 ((name . "if")
  (signature
   syntax-rules
   ()
   ((_ test consequent))
   ((_ test consequent alternate)))
  (desc . "An if expression is evaluated as follows: first, test is evaluated. If it yields a true value (see section 6.3), then consequent is evaluated and its values are returned. Otherwise alternate is evaluated and its values are returned. If test yields a false value and no alternate is specified, then the result of the expression is unspecified."))
 ((name . "include")
  (signature syntax-rules () ((_ string1 string2 ...)))
  (desc . "Include takes one or more filenames expressed as string literals, applies an implementation-specific algorithm to find corresponding files, reads the contents of the files in the specified order as if by repeated applications of read, and effectively replaces the include expression with a begin expression containing what was read from the files. Note: Implementations are encouraged to search for files in the directory which contains the including file, and to provide a way for users to specify other directories to search."))
 ((name . "include-ci")
  (signature syntax-rules () ((_ string1 string2 ...)))
  (desc . "Include-ci takes one or more filenames expressed as string literals, applies an implementation-specific algorithm to find corresponding files, reads the contents of the files in the specified order as if by repeated applications of read, and effectively replaces the include-ci expression with a begin expression containing what was read from the files. Include-ci reads each file as if it began with the #!fold-case directive. Note: Implementations are encouraged to search for files in the directory which contains the including file, and to provide a way for users to specify other directories to search."))
 ((name . "inexact") (signature lambda ((number? z)) inexact?) (tags pure) (desc . "The procedure inexact returns an inexact representation of z. The value returned is the inexact number that is numerically closest to the argument. For inexact arguments, the result is the same as the argument. For exact complex numbers, the result is a complex number whose real and imaginary parts are the result of applying inexact to the real and imaginary parts of the argument, respectively. If an exact argument has no reasonably close inexact equivalent (in the sense of =), then a violation of an implementation restriction may be reported."))
 ((name . "inexact?")
  (signature lambda ((number? z)) boolean?)
  (tags pure)
  (supertypes number?)
  (desc . "This numerical predicate provides tests for the exactness of a quantity. For any Scheme number, precisely one of exact? and inexact? predicates is true."))
 ((name . "input-port-open?")
  (signature lambda ((input-port? port)) boolean?)
  (desc . "Returns #t if port is still open and capable of performing input, and #f otherwise."))
 ((name . "input-port?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes port?))
 ((name . "integer->char") (signature lambda ((integer? n)) char?) (tags pure) (desc . "Given an exact integer that is the value returned by a character when char->integer is applied to it, integer->char returns that character."))
 ((name . "integer?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes rational?))
 ((name . "lambda")
  (signature syntax-rules () ((_ formals body) procedure?))
  (subsigs
   (formals
    (pattern
     (variable1 ...)
     variable
     (variable1 ... variable_n . variable_n+1))))
  (desc . "A lambda expression evaluates to a procedure. The environment in effect when the lambda expression was evaluated is remembered as part of the procedure. When the procedure is later called with some actual arguments, the environment in which the lambda expression was evaluated will be extended by binding the variables in the formal argument list to fresh locations, and the corresponding actual argument values will be stored in those locations. (A fresh location is one that is distinct from every previously existing location.) Next, the expressions in the body of the lambda expression (which, if it contains definitions, represents a letrec* form -- see section 4.2.2) will be evaluated sequentially in the extended environment. The results of the last expression in the body will be returned as the results of the procedure call. Each procedure created as the result of evaluating a lambda expression is (conceptually) tagged with a storage location, in order to make eqv? and eq? work on procedures (see section 6.1)."))
 ((name . "lcm") (signature lambda ((integer? n) ...) integer?) (tags pure) (desc . "This procedure returns the least common multiple of its arguments. The result is always non-negative."))
 ((name . "length") (signature lambda ((list? list)) integer?) (tags pure) (desc . "Returns the length of list."))
 ((name . "let")
  (signature
   syntax-rules
   ()
   ((_ ((var1 init1) ...) body))
   ((_ name ((var1 init1) ...) body)))
  (desc . "The inits are evaluated in the current environment (in some unspecified order), the variables are bound to fresh locations holding the results, the body is evaluated in the extended environment, and the values of the last expression of body are returned. Each binding of a variable has body as its region. \"Named let\" is a variant on the syntax of let which provides a more general looping construct than do and can also be used to express recursion. It has the same syntax and semantics as ordinary let except that variable is bound within body to a procedure whose formal arguments are the bound variables and whose body is body. Thus the execution of body can be repeated by invoking the procedure named by variable."))
 ((name . "let*")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings (pattern ((variable1 init1) ...))))
  (desc . "The let* binding construct is similar to let, but the bindings are performed sequentially from left to right, and the region of a binding indicated by (variable init) is that part of the let* expression to the right of the binding. Thus the second binding is done in an environment in which the first binding is visible, and so on. The variables need not be distinct."))
 ((name . "let-syntax")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs
   (bindings (pattern ((keyword transformer-spec) ...)))
   (transformer-spec (value transformer-spec)))
  (desc . "The body is expanded in the syntactic environment obtained by extending the syntactic environment of the let-syntax expression with macros whose keywords are the keywords, bound to the specified transformers. Each binding of a keyword has body as its region."))
 ((name . "letrec")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings (pattern ((variable1 init1) ...))))
  (desc . "The variables are bound to fresh locations holding unspecified values, the inits are evaluated in the resulting environment (in some unspecified order), each variable is assigned to the result of the corresponding init, the body is evaluated in the resulting environment, and the values of the last expression in body are returned. Each binding of a variable has the entire letrec expression as its region, making it possible to define mutually recursive procedures."))
 ((name . "letrec*")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings (pattern ((variable1 init1) ...))))
  (desc . "The variables are bound to fresh locations, each variable is assigned in left-to-right order to the result of evaluating the corresponding init, the body is evaluated in the resulting environment, and the values of the last expression in body are returned. Despite the left-to-right evaluation and assignment order, each binding of a variable has the entire letrec* expression as its region, making it possible to define mutually recursive procedures. If it is not possible to evaluate each init without assigning or referring to the value of the corresponding variable or the variable of any of the bindings that follow it in bindings, it is an error. Another restriction is that it is an error to invoke the continuation of an init more than once."))
 ((name . "letrec-syntax")
  (signature syntax-rules () ((_ bindings body)))
  (subsigs (bindings (pattern ((keyword transformer-spec) ...))))
  (desc . "The body is expanded in the syntactic environment obtained by extending the syntactic environment of the letrec-syntax expression with macros whose keywords are the keywords, bound to the specified transformers. Each binding of a keyword has the transformer specs as well as the body within its region, so the transformers can transcribe expressions into uses of the macros introduced by the letrec-syntax expression."))
 ((name . "list") (signature lambda (obj ...) list?) (tags pure) (desc . "Returns a newly allocated list of its arguments."))
 ((name . "list->string")
  (signature lambda ((list? list)) string?)
  (tags pure)
  (subsigs
    (list (list (char? c))))
  (desc . "list->string returns a newly allocated string formed from the elements in the list list. The order is preserved. string->list and list->string are inverses so far as equal? is concerned."))
 ((name . "list->vector")
  (signature lambda ((list? list)) vector?)
  (tags pure)
  (desc . "The list->vector procedure returns a newly created vector initialized to the elements of the list list. The order is preserved."))
 ((name . "list-copy") (signature lambda (obj) *) (tags pure) (desc . "Returns a newly allocated copy of the given obj if it is a list. Only the pairs themselves are copied; the cars of the result are the same (in the sense of eqv?) as the cars of list . If obj is an improper list, so is the result, and the final cdrs are the same in the sense of eqv?. An obj which is not a list is returned unchanged. It is an error if obj is a circular list."))
 ((name . "list-ref")
  (signature lambda ((list? list) (integer? k)) *)
  (tags pure)
  (desc . "It is an error if list has fewer than k elements. Returns the kth element of list. (This is the same as the car of (list-tail list k).)"))
 ((name . "list-set!")
  (signature lambda ((list? list) (integer? k) obj) undefined)
  (desc . "It is an error if k is not a valid index of list. The list-set! procedure stores obj in element k of list."))
 ((name . "list-tail")
  (signature lambda ((list? list) (integer? k)) list?)
  (tags pure)
  (desc . "It is an error if list has fewer than k elements. Returns the sublist of list obtained by omitting the first k elements."))
 ((name . "list?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a list. Otherwise, it returns #f. By definition, all lists have finite length and are terminated by the empty list."))
 ((name . "make-bytevector")
  (signature
   case-lambda
   (((integer? k)) bytevector?)
   (((integer? k) (integer? byte)) bytevector?))
  (tags pure)
  (desc . "The make-bytevector procedure returns a newly allocated bytevector of length k. If byte is given, then all elements of the bytevector are initialized to byte, otherwise the contents of each element are unspecified."))
 ((name . "make-list")
  (signature case-lambda (((integer? k)) list?) (((integer? k) obj) list?))
  (tags pure)
  (desc . "Returns a newly allocated list of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified."))
 ((name . "make-string")
  (signature
   case-lambda
   (((integer? k)) string?)
   (((integer? k) (char? char)) string?))
  (tags pure)
  (desc . "The make-string procedure returns a newly allocated string of length k. If char is given, then all the characters of the string are initialized to char, otherwise the contents of the string are unspecified."))
 ((name . "make-vector")
  (signature
   case-lambda
   (((integer? k)) vector?)
   (((integer? k) fill) vector?))
  (tags pure)
  (desc . "Returns a newly allocated vector of k elements. If a second argument is given, then each element is initialized to fill . Otherwise the initial contents of each element is unspeci- fied."))
 ((name . "map")
  (signature lambda ((procedure? proc) (list? list1) (list? list2) ...) list?)
  (subsigs (proc (lambda (obj1 obj2 ...) *)))
  (tags pure)
  (desc . "It is an error if proc does not accept as many arguments as there are lists and return a single value. The map procedure applies proc element-wise to the elements of the lists and returns a list of the results, in order. If more than one list is given and not all lists have the same length, map terminates when the shortest list runs out. It is an error for proc to mutate any of the lists. The dynamic order in which proc is applied to the elements of the lists is unspecified. If multiple returns occur from map, the values returned by earlier returns are not mutated."))
 ((name . "max")
  (signature lambda ((real? x1) (real? x2) ...) real?)
  (tags pure)
  (desc . "This procedure returns the maximum of its arguments. Note: If any argument is inexact, then the result will also be inexact (unless the procedure can prove that the inaccuracy is not large enough to affect the result, which is possible only in unusual implementations). If min or max is used to compare numbers of mixed exactness, and the numerical value of the result cannot be represented as an inexact number without loss of accuracy, then the procedure may report a violation of an implementation restriction."))
 ((name . "member")
  (signature
   case-lambda
   ((obj (list? list)) (or #f list?))
   ((obj (list? list) (procedure? compare)) (or #f list?)))
  (subsigs (compare (lambda (obj1 obj2) *)))
  (tags pure)
  (desc . "This procedure returns the first sublist of list whose car is obj , where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list . If obj does not occur in list , then #f (not the empty list) is returned. The member procedure uses compare, if given, and equal? otherwise to compare obj with the elements of list."))
 ((name . "memq")
  (signature lambda (obj (list? list)) (or #f list?))
  (tags pure)
  (desc . "This procedure returns the first sublist of list whose car is obj , where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list . If obj does not occur in list , then #f (not the empty list) is returned. The memq procedure uses eq? to compare obj with the elements of list."))
 ((name . "memv")
  (signature lambda (obj (list? list)) (or #f list?))
  (tags pure)
  (desc . "This procedure returns the first sublist of list whose car is obj , where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list . If obj does not occur in list , then #f (not the empty list) is returned. The memv procedure uses eqv? to compare obj with the elements of list."))
 ((name . "min")
  (signature lambda ((real? x1) (real? x2) ...) real?)
  (tags pure)
  (desc . "This procedure returns the minimum of its arguments. Note: If any argument is inexact, then the result will also be inexact (unless the procedure can prove that the inaccuracy is not large enough to affect the result, which is possible only in unusual implementations). If min or max is used to compare numbers of mixed exactness, and the numerical value of the result cannot be represented as an inexact number without loss of accuracy, then the procedure may report a violation of an implementation restriction."))
 ((name . "modulo")
  (signature lambda ((integer? n1) (integer? n2)) integer?)
  (tags pure)
  (desc . "The modulo is equivalent to floor-remainder."))
 ((name . "negative?") (signature lambda ((real? x)) boolean?) (tags pure))
 ((name . "newline")
  (signature case-lambda (() undefined) (((output-port? port)) undefined))
  (desc . "Writes an end of line to textual output port. Returns an unspecified value."))
 ((name . "not") (signature lambda (obj) boolean?) (tags pure) (desc . "The not procedure returns #t if obj is false, and returns #f otherwise."))
 ((name . "null?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes list?)
  (desc . "Returns #t if obj is the empty list, otherwise returns #f."))
 ((name . "number->string")
  (signature
   case-lambda
   (((number? z)) string?)
   (((number? z) (integer? radix)) string?))
  (tags pure)
  (desc . "It is an error if radix is not one of 2, 8, 10, or 16. The procedure number->string takes a number and a radix and returns as a string an external representation of the given number in the given radix.  It is an error if no possible result makes this expression true. If omitted, radix defaults to 10. If z is inexact, the radix is 10, and the above expression can be satisfied by a result that contains a decimal point, then the result contains a decimal point and is expressed using the minimum number of digits (exclusive of exponent and trailing zeroes) needed to make the above expression true [4, 5]; otherwise the format of the result is unspecified. The result returned by number->string never contains an explicit radix prefix. Note: The error case can occur only when z is not a complex number or is a complex number with a non-rational real or imaginary part. Rationale: If z is an inexact number and the radix is 10, then the above expression is normally satisfied by a result containing a decimal point. The unspecified case allows for infinities, NaNs, and unusual representations."))
 ((name . "number?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "numerator") 
  (signature lambda ((rational? q)) integer?)
  (tags pure)
  (desc . "This procedure returns the numerator of its argument; the result is computed as if the argument was represented as a fraction in lowest terms."))
 ((name . "odd?")
  (signature lambda ((integer? n)) boolean?)
  (tags pure predicate))
 ((name . "open-input-bytevector")
  (signature lambda ((bytevector? bytevector)) input-port?)
  (tags pure)
  (desc . "Takes a bytevector and returns a binary input port that delivers bytes from the bytevector."))
 ((name . "open-output-bytevector")
  (signature lambda () output-port?)
  (tags pure)
  (desc . "Returns a binary output port that will accumulate bytes for retrieval by get-output-bytevector."))
 ((name . "or")
  (signature syntax-rules () ((_ test1 ...)))
  (desc . "The test expressions are evaluated from left to right, and the value of the first expression that evaluates to a true value (see section 6.3) is returned. Any remaining expressions are not evaluated. If all expressions evaluate to #f or if there are no expressions, then #f is returned."))
 ((name . "output-port-open?")
  (signature lambda ((output-port? port)) boolean?)
  (desc . "Returns #t if port is still open and capable of performing output, and #f otherwise."))
 ((name . "output-port?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes port?))
 ((name . "pair?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "The pair? predicate returns #t if obj is a pair, and otherwise returns #f."))
 ((name . "peek-char")
  (signature
   case-lambda
   (() (or eof-object? char?))
   (((input-port? port)) (or eof-object? char?)))
  (desc . "Returns the next character available from the textual input port, but without updating the port to point to the following character. If no more characters are available, an end-of-file object is returned. Note: The value returned by a call to peek-char is the same as the value that would have been returned by a call to read-char with the same port. The only diã„¦ence is that the very next call to read-char or peek-char on that port will return the value returned by the preceding call to peek-char. In particular, a call to peek-char on an interactive port will hang waiting for input whenever a call to read-char would have hung. (read-line) procedure"))
 ((name . "peek-u8")
  (signature
   case-lambda
   (() (or eof-object? integer?))
   (((input-port? port)) (or eof-object? integer?)))
  (desc . "Returns the next byte available from the binary input port, but without updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned."))
 ((name . "port?")
  (signature lambda (obj) boolean?)
  (tags pure predicate))
 ((name . "positive?")
  (signature lambda ((real? x)) boolean?)
  (tags pure))
 ((name . "procedure?")
  (signature lambda (obj) boolean?)
  (tags pure predicate))
 ((name . "quasiquote")
  (signature syntax-rules () ((_ qq-template)))
  (desc . "\"Quasiquote\" expressions are useful for constructing a list or vector structure when some but not all of the desired structure is known in advance. If no commas appear within the qq template, the result of evaluating qq template is equivalent to the result of evaluating 'qq template. If a comma appears within the qq template, however, the expression following the comma is evaluated (\"unquoted\") and its result is inserted into the structure instead of the comma and the expression. If a comma appears followed without intervening whitespace by a commercial at-sign (@), then it is an error if the following expression does not evaluate to a list; the opening and closing parentheses of the list are then \"stripped away\" and the elements of the list are inserted in place of the comma at-sign expression sequence. A comma at-sign normally appears only within a list or vector qq template. Note: In order to unquote an identifier beginning with @, it is necessary to use either an explicit unquote or to put whitespace after the comma, to avoid colliding with the comma at-sign sequence. Quasiquote expressions can be nested. Substitutions are made only for unquoted components appearing at the same nesting level as the outermost quasiquote. The nesting level increases by one inside each successive quasiquotation, and decreases by one inside each unquotation. A quasiquote expression may return either newly allocated, mutable objects or literal structure for any structure that is constructed at run time during the evaluation of the expression. Portions that do not need to be rebuilt are always literal."))
 ((name . "quote")
  (signature syntax-rules () ((_ datum)))
  (desc . "(quote datum) evaluates to datum. Datum can be any external representation of a Scheme object (see section 3.3). This notation is used to include literal constants in Scheme code. (quote datum) can be abbreviated as 'datum. The two notations are equivalent in all respects. Numerical constants, string constants, character constants, vector constants, bytevector constants, and boolean constants evaluate to themselves; they need not be quoted. As noted in section 3.4, it is an error to attempt to alter a constant (i.e. the value of a literal expression) using a mutation procedure like set-car! or string-set!."))
 ((name . "quotient")
  (signature lambda ((integer? n1) (integer? n2)) integer?)
  (tags pure)
  (desc . "The quotient procedure is equivalent to truncate-quotient."))
 ((name . "raise-continuable")
  (signature lambda (obj) undefined)
  (desc . "Raises an exception by invoking the current exception handler on obj. The handler is called with the same dynamic environment as the call to raise-continuable, except that: (1) the current exception handler is the one that was in place when the handler being called was installed, and (2) if the handler being called returns, then it will again become the current exception handler. If the handler returns, the values it returns become the values returned by the call to raise-continuable."))
 ((name . "rational?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes real?))
 ((name . "rationalize")
  (signature lambda ((real? x) (real? y)) rational?)
  (tags pure)
  (desc . "The rationalize procedure returns the simplest rational number differing from x by no more than y."))
 ((name . "read-bytevector")
  (signature
   case-lambda
   (((integer? k)) bytevector?)
   (((integer? k) (input-port? port)) bytevector?))
  (desc . "Reads the next k bytes, or as many as are available before the end of file, from the binary input port into a newly allocated bytevector in left-to-right order and returns the bytevector. If no bytes are available before the end of file, an end-of-file object is returned."))
 ((name . "read-bytevector!")
  (signature
   case-lambda
   (((bytevector? bytevector)) (or eof-object? integer?))
   (((bytevector? bytevector) (input-port? port)) (or eof-object? integer?))
   (((bytevector? bytevector) (input-port? port) (integer? start))
    (or eof-object? integer?))
   (((bytevector? bytevector)
     (input-port? port)
     (integer? start)
     (integer? end))
    (or eof-object? integer?)))
  (desc . "Reads the next end âˆ’ start bytes, or as many as are available before the end of file, from the binary input port into bytevector in left-to-right order beginning at the start position. If end is not supplied, reads until the end of bytevector has been reached. If start is not supplied, reads beginning at position 0. Returns the number of bytes read. If no bytes are available, an end-of-file object is returned."))
 ((name . "read-char")
  (signature
   case-lambda
   (() (or eof-object? char?))
   (((input-port? port)) (or eof-object? char?)))
  (desc . "Returns the next character available from the textual input port, updating the port to point to the following character. If no more characters are available, an end-of-file object is returned."))
 ((name . "read-error?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "read-error?, file-error? Error type predicates. Returns #t if obj is an object raised by the read procedure or by the inability to open an input or output port on a file, respectively. Otherwise, it returns #f."))
 ((name . "read-line")
  (signature
   case-lambda
   (() (or eof-object? string?))
   (((input-port? port)) (or eof-object? string?)))
  (desc . "Returns the next line of text available from the textual input port, updating the port to point to the following character. If an end of line is read, a string containing all of the text up to (but not including) the end of line is returned, and the port is updated to point just past the end of line. If an end of file is encountered before any end of line is read, but some characters have been read, a string containing those characters is returned. If an end of file is encountered before any characters are read, an end-of-file object is returned. For the purpose of this procedure, an end of line consists of either a linefeed character, a carriage return character, or a sequence of a carriage return character followed by a linefeed character. Implementations may also recognize other end of line characters or sequences."))
 ((name . "read-string")
  (signature
   case-lambda
   (((integer? k)) (or eof-object? string?))
   (((integer? k) (input-port? port)) (or eof-object? string?)))
  (desc . "Reads the next k characters, or as many as are available before the end of file, from the textual input port into a newly allocated string in left-to-right order and returns the string. If no characters are available before the end of file, an end-of-file object is returned."))
 ((name . "read-u8")
  (signature
   case-lambda
   (() (or eof-object? integer?))
   (((input-port? port)) (or eof-object? integer?)))
  (desc . "Returns the next byte available from the binary input port, updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned.")) 
 ((name . "real?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes complex?))
 ((name . "remainder")
  (signature lambda ((integer? n1) (integer? n2)) integer?)
  (tags pure)
  (desc . "The remainder procedure is equivalent to truncate-remainder."))
 ((name . "reverse")
  (signature lambda ((list? list)) list?)
  (tags pure)
  (desc . "Returns a newly allocated list consisting of the elements of list in reverse order."))
 ((name . "round")
  (signature lambda ((real? x)) integer?)
  (tags pure)
  (desc . "The round returns the closest integer to x, rounding to even when x is halfway between two integers. Rationale: The round procedure rounds to even for consistency with the default rounding mode specified by the IEEE 754 IEEE floating-point standard. Note: If the argument to one of these procedures is inexact, then the result will also be inexact. If an exact value is needed, the result can be passed to the exact procedure. If the argument is infinite or a NaN, then it is returned."))
 ((name . "set!")
  (signature syntax-rules () ((_ variable expression)))
  (desc . "Expression is evaluated, and the resulting value is stored in the location to which variable is bound.  It is an error if variable is not bound either in some region enclosing the set! expression or else globally. The result of the set! expression is unspecified."))
 ((name . "set-car!")
  (signature lambda ((pair? pair) obj) undefined)
  (desc . "Stores obj in the car field of pair."))
 ((name . "set-cdr!")
  (signature lambda ((pair? pair) obj) undefined)
  (desc . "Stores obj in the cdr field of pair."))
 ((name . "square")
  (signature lambda ((number? z)) number?)
  (tags pure) (desc . "Returns the square of z. This is equivalent to (* z z)."))
 ((name . "string")
  (signature lambda ((char? char) ...) string?)
  (tags pure)
  (desc . "Returns a newly allocated string composed of the arguments. It is analogous to list."))
 ((name . "string->list")
  (signature
   case-lambda
   (((string? string)) list?)
   (((string? string) (integer? start)) list?)
   (((string? string) (integer? start) (integer? end)) list?))
  (tags pure)
  (subsigs
    (return (list (char? c))))
  (desc . "The string->list procedure returns a newly allocated list of the characters of string between start and end. The order is preserved. string->list and list->string are inverses so far as equal? is concerned."))
 ((name . "string->number")
  (signature
   case-lambda
   (((string? string)) number?)
   (((string? string) (integer? radix)) number?))
  (tags pure)
  (desc . "Returns a number of the maximally precise representation expressed by the given string. It is an error if radix is not 2, 8, 10, or 16.  If supplied, radix is a default radix that will be overridden if an explicit radix prefix is present in string (e.g. \"#o177\"). If radix is not supplied, then the default radix is 10. If string is not a syntactically valid notation for a number, or would result in a number that the implementation cannot represent, then string->number returns #f. An error is never signaled due to the content of string. Note: The domain of string->number may be restricted by implementations in the following ways. If all numbers supported by an implementation are real, then string->number is permitted to return #f whenever string uses the polar or rectangular notations for complex numbers. If all numbers are integers, then string->number may return #f whenever the fractional notation is used. If all numbers are exact, then string->number may return #f whenever an exponent marker or explicit exactness prefix is used. If all inexact numbers are integers, then string->number may return #f whenever a decimal point is used. The rules used by a particular implementation for string->number must also be applied to read and to the routine that reads programs, in order to maintain consistency between internal numeric processing, I/O, and the processing of programs. As a consequence, the R5RS permission to return #f when string has an explicit radix prefix has been withdrawn."))
 ((name . "string->symbol")
  (signature lambda ((string? string)) symbol?)
  (tags pure)
  (desc . "Returns the symbol whose name is string. This procedure can create symbols with names containing special characters that would require escaping when written, but does not interpret escapes in its input."))
 ((name . "string->utf8")
  (signature
   case-lambda
   (((string? string)) bytevector?)
   (((string? string) (integer? start)) bytevector?)
   (((string? string) (integer? start) (integer? end)) bytevector?))
  (tags pure)
  (desc . "This procedure translates between strings and bytevectors that encode those strings using the UTF-8 encoding. The string->utf8 procedure encodes the characters of a string between start and end and returns the corresponding bytevector."))
 ((name . "string->vector")
  (signature
   case-lambda
   (((string? string)) vector?)
   (((string? string) (integer? start)) vector?)
   (((string? string) (integer? start) (integer? end)) vector?))
  (tags pure)
  (subsigs
    (return (vector (char? char))))
  (desc . "It is an error if any element of vector between start and end is not a character. The string->vector procedure returns a newly created vector initialized to the elements of the string string between start and end. The order is preserved."))
 ((name . "string-append")
  (signature lambda ((string? string) ...) string?)
  (tags pure)
  (desc . "Returns a newly allocated string whose characters are the concatenation of the characters in the given strings."))
 ((name . "string-copy")
  (signature
   case-lambda
   (((string? string)) string?)
   (((string? string) (integer? start)) string?)
   (((string? string) (integer? start) (integer? end)) string?))
  (tags pure))
 ((name . "string-copy!")
  (signature
   case-lambda
   (((string? to) (integer? at) (string? from)) undefined)
   (((string? to) (integer? at) (string? from) (integer? start)) undefined)
   (((string? to) (integer? at) (string? from) (integer? start) (integer? end))
    undefined))
  (desc . "Returns a newly allocated copy of the part of the given string between start and end."))
 ((name . "string-fill!")
  (signature
   case-lambda
   (((string? string) (char? fill)) undefined)
   (((string? string) (char? fill) (integer? start)) undefined)
   (((string? string) (char? fill) (integer? start) (integer? end))
    undefined))
  (desc . "It is an error if fill is not a character. The string-fill! procedure stores fill in the elements of string between start and end."))
 ((name . "string-for-each")
  (signature
   lambda
   ((procedure? proc) (string? string1) (string? string2) ...)
   undefined)
  (subsigs (proc (lambda ((string? string) ...) undefined)))
  (desc . "It is an error if proc does not accept as many arguments as there are strings. The arguments to string-for-each are like the arguments to string-map, but string-for-each calls proc for its side effects rather than for its values. Unlike string-map, string-for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by string-for-each is unspecified. If more than one string is given and not all strings have the same length, string-for-each terminates when the shortest string runs out. It is an error for proc to mutate any of the strings."))
 ((name . "string-length")
  (signature lambda ((string? string)) integer?)
  (tags pure)
  (desc . "Returns the number of characters in the given string."))
 ((name . "string-map")
  (signature
   lambda
   ((procedure? proc) (string? string1) (string? string2) ...)
   string?)
  (subsigs (proc (lambda ((char? c1) ...) char?)))
  (tags pure)
  (desc . "It is an error if proc does not accept as many arguments as there are strings and return a single character. The string-map procedure applies proc element-wise to the elements of the strings and returns a string of the results, in order. If more than one string is given and not all strings have the same length, string-map terminates when the shortest string runs out. The dynamic order in which proc is applied to the elements of the strings is unspecified. If multiple returns occur from string-map, the values returned by earlier returns are not mutated."))
 ((name . "string-ref")
  (signature lambda ((string? string) (integer? k)) char?)
  (tags pure)
  (desc . "It is an error if k is not a valid index of string. The string-ref procedure returns character k of string using zero-origin indexing. There is no requirement for this procedure to execute in constant time."))
 ((name . "string-set!")
  (signature lambda ((string? string) (integer? k) (char? char)) undefined)
  (desc . "It is an error if k is not a valid index of string. The string-set! procedure stores char in element k of string. There is no requirement for this procedure to execute in constant time."))
 ((name . "string<=?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure)
  (desc . "This procedure returns #t if its arguments are monotonically non-decreasing. This predicate is required to be transitive. The procedure compares strings in an implementation defined way. One approach is to make them the lexicographic extensions to strings of the corresponding orderings on characters. In that case, string<? would be the lexicographic ordering on strings induced by the ordering char<? on characters, and if the two strings differ in length but are the same up to the length of the shorter string, the shorter string would be considered to be lexicographically less than the longer string. However, it is also permitted to use the natural ordering imposed by the implementationâ€™s internal representation of strings, or a more complex locale-specific ordering. In all cases, a pair of strings must satisfy exactly one of string<?, string=?, and string>?, and must satisfy string<=? if and only if they do not satisfy string>? and string>=? if and only if they do not satisfy string<?."))
 ((name . "string<?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure)
  (desc . "This procedure returns #t if its arguments are monotonically increasing. This predicate is required to be transitive. The procedure compares strings in an implementation defined way. One approach is to make them the lexicographic extensions to strings of the corresponding orderings on characters. In that case, string<? would be the lexicographic ordering on strings induced by the ordering char<? on characters, and if the two strings differ in length but are the same up to the length of the shorter string, the shorter string would be considered to be lexicographically less than the longer string. However, it is also permitted to use the natural ordering imposed by the implementationâ€™s internal representation of strings, or a more complex locale-specific ordering. In all cases, a pair of strings must satisfy exactly one of string<?, string=?, and string>?, and must satisfy string<=? if and only if they do not satisfy string>? and string>=? if and only if they do not satisfy string<?."))
 ((name . "string=?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure)
  (desc . "Returns #t if all the strings are the same length and contain exactly the same characters in the same positions, otherwise returns #f."))
 ((name . "string>=?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure)
  (desc . "This procedure returns #t if its arguments are monotonically non-increasing. This predicate is required to be transitive. The procedure compares strings in an implementation defined way. One approach is to make them the lexicographic extensions to strings of the corresponding orderings on characters. In that case, string<? would be the lexicographic ordering on strings induced by the ordering char<? on characters, and if the two strings differ in length but are the same up to the length of the shorter string, the shorter string would be considered to be lexicographically less than the longer string. However, it is also permitted to use the natural ordering imposed by the implementationâ€™s internal representation of strings, or a more complex locale-specific ordering. In all cases, a pair of strings must satisfy exactly one of string<?, string=?, and string>?, and must satisfy string<=? if and only if they do not satisfy string>? and string>=? if and only if they do not satisfy string<?."))
 ((name . "string>?")
  (signature
   lambda
   ((string? string1) (string? string2) (string? string3) ...)
   boolean?)
  (tags pure)
  (desc . "This procedure returns #t if its arguments are monotonically decreasing. This predicate is required to be transitive. The procedure compares strings in an implementation defined way. One approach is to make them the lexicographic extensions to strings of the corresponding orderings on characters. In that case, string<? would be the lexicographic ordering on strings induced by the ordering char<? on characters, and if the two strings differ in length but are the same up to the length of the shorter string, the shorter string would be considered to be lexicographically less than the longer string. However, it is also permitted to use the natural ordering imposed by the implementationâ€™s internal representation of strings, or a more complex locale-specific ordering. In all cases, a pair of strings must satisfy exactly one of string<?, string=?, and string>?, and must satisfy string<=? if and only if they do not satisfy string>? and string>=? if and only if they do not satisfy string<?."))
 ((name . "string?")
  (signature lambda (obj) boolean?)
  (tags pure predicate))
 ((name . "substring")
  (signature lambda ((string? string) (integer? start) (integer? end)) string?)
  (tags pure)
  (desc . "The substring procedure returns a newly allocated string formed from the characters of string beginning with index start and ending with index end. This is equivalent to calling string-copy with the same arguments, but is provided for backward compatibility and stylistic flexibility."))
 ((name . "symbol->string")
  (signature lambda ((symbol? symbol)) string?)
  (tags pure)
  (desc . "Returns the name of symbol as a string, but without adding escapes. It is an error to apply mutation procedures like string-set! to strings returned by this procedure.")) 
 ((name . "symbol=?")
  (signature
   lambda
   ((symbol? symbol1) (symbol? symbol2) (symbol? symbol3) ...)
   boolean?)
  (tags pure)
  (desc . "Returns #t if all the arguments are symbols and all have the same names in the sense of string=?. Note: The definition above assumes that none of the arguments are uninterned symbols."))
 ((name . "symbol?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "syntax-error") 
  (signature syntax-rules () ((_ message args ...)))
  (desc . "syntax-error behaves similarly to error (6.11) except that implementations with an expansion pass separate from evaluation should signal an error as soon as syntax-error is expanded. This can be used as a syntax-rules template for a pattern that is an invalid use of the macro, which can provide more descriptive error messages. message is a string literal, and args arbitrary expressions providing additional information. Applications cannot count on being able to catch syntax errors with exception handlers or guards."))
 ((name . "syntax-rules")
  (signature
   syntax-rules
   (_)
   ((_ (literal ...) syntax-rule ...) transformer-spec)
   ((_ ellipsis (literal ...) syntax-rule ...) transformer-spec))
  (subsigs
   (syntax-rule (pattern (pattern template)))
   (pattern
    (pattern
     _
     identifier
     constant
     (pattern ...)
     (pattern pattern ... . pattern)
     (pattern ... pattern ellipsis pattern ...)
     (pattern ... pattern ellipsis pattern ... . pattern)
     (_append "#" (pattern ...))
     (_append "#" (pattern ... pattern ellipsis pattern ...))))
   (template
    (pattern
     identifier
     constant
     (element ...)
     (element element ... . template)
     (ellipsis template)
     (_append "#" (element ...))))
   (element (pattern template (_append template ellipsis))))
  (desc . "An instance of syntax-rules produces a new macro transformer by specifying a sequence of hygienic rewrite rules. A use of a macro whose keyword is associated with a transformer specified by syntax-rules is matched against the patterns contained in the syntax rulei, beginning with the leftmost syntax rule. When a match is found, the macro use is transcribed hygienically according to the template. An identifier appearing within a pattern can be an underscore (_), a literal identifier listed in the list of literali, or the ellipsis. All other identifiers appearing within a pattern are pattern variables. The keyword at the beginning of the pattern in a syntax rule is not involved in the matching and is considered neither a pattern variable nor a literal identifier. Pattern variables match arbitrary input elements and are used to refer to elements of the input in the template. It is an error for the same pattern variable to appear more than once in a pattern. Underscores also match arbitrary input elements but are not pattern variables and so cannot be used to refer to those elements. If an underscore appears in the literal list, then that takes precedence and underscores in the pattern match as literals. Multiple underscores can appear in a pattern. Identifiers that appear in (literal ...) are interpreted as literal identifiers to be matched against corresponding elements of the input. An element in the input matches a literal identifier if and only if it is an identifier and either both its occurrence in the macro expression and its occurrence in the macro definition have the same lexical binding, or the two identifiers are the same and both have no lexical binding. A subpattern followed by ellipsis can match zero or more elements of the input, unless ellipsis appears in the literals, in which case it is matched as a literal. It is an error to use a macro keyword, within the scope of its binding, in an expression that does not match any of the patterns. When a macro use is transcribed according to the template of the matching hsyntax rulei, pattern variables that occur in the template are replaced by the elements they match in the input. Pattern variables that occur in subpatterns followed by one or more instances of the identifier ellipsis are allowed only in subtemplates that are followed by as many instances of ellipsis. They are replaced in the output by all of the elements they match in the input, distributed as indicated. It is an error if the output cannot be built up as specified. Identifiers that appear in the template but are not pattern variables or the identifier ellipsis are inserted into the output as literal identifiers. If a literal identifier is inserted as a free identifier then it refers to the binding of that identifier within whose scope the instance of syntax-rules appears. If a literal identifier is inserted as a bound identifier then it is in effect renamed to prevent inadvertent captures of free identifiers. A template of the form (ellipsis template) is identical to template, except that ellipses within the template have no special meaning. That is, any ellipses contained within template are treated as ordinary identifiers. In particular, the template (ellipsis ellipsis) produces a single ellipsis. This allows syntactic abstractions to expand into code containing ellipses."))
 ((name . "textual-port?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (supertypes port?))
 ((name . "truncate")
  (signature lambda ((real? x)) integer?)
  (tags pure)
  (desc . "The truncate procedure returns the integer closest to x whose absolute value is not larger than the absolute value of x. Note: If the argument to this procedure is inexact, then the result will also be inexact. If an exact value is needed, the result can be passed to the exact procedure. If the argument is infinite or a NaN, then it is returned."))
 ((name . "truncate-quotient")
  (signature lambda ((integer? n1) (integer? n2)) integer?)
  (tags pure)
  (desc . "This procedure implements number-theoretic (integer) division. It is an error if n2 is zero. The procedure computes a quotient nq and remainder nr such that n1 = n2 * nq + nr."))
 ((name . "truncate-remainder")
  (signature lambda ((integer? n1) (integer? n2)) integer?)
  (tags pure)
  (desc . "This procedure implements number-theoretic (integer) division. It is an error if n2 is zero. The procedure computes a quotient nq and remainder nr such that n1 = n2 * nq + nr."))
 ((name . "truncate/")
  (signature lambda ((integer? n1) (integer? n2)) (values integer? integer?))
  (tags pure)
  (desc . "This procedure implements number-theoretic (integer) division. It is an error if n2 is zero. The procedure computes a quotient nq and remainder nr such that n1 = n2 * nq + nr."))
 ((name . "u8-ready?")
  (signature case-lambda 
             (() boolean?)
             (((input-port? port)) boolean?))
  (desc . "Returns #t if a byte is ready on the binary input port and returns #f otherwise. If u8-ready? returns #t then the next read-u8 operation on the given port is guaranteed not to hang. If the port is at end of file then u8-ready? returns #t."))
 ((name . "unless")
  (signature syntax-rules () ((_ test expression1 expression2 ...)))
  (desc . "The test is evaluated, and if it evaluates to #f, the expressions are evaluated in order. The result of the unless expression is unspecified."))
 ((name . "unquote") 
  (signature syntax-rules () ((_ expression)))
  (desc . "\"Quasiquote\" expressions are useful for constructing a list or vector structure when some but not all of the desired structure is known in advance. If no commas appear within the qq template, the result of evaluating qq template is equivalent to the result of evaluating 'qq template. If a comma appears within the qq template, however, the expression following the comma is evaluated (\"unquoted\") and its result is inserted into the structure instead of the comma and the expression. If a comma appears followed without intervening whitespace by a commercial at-sign (@), then it is an error if the following expression does not evaluate to a list; the opening and closing parentheses of the list are then \"stripped away\" and the elements of the list are inserted in place of the comma at-sign expression sequence. A comma at-sign normally appears only within a list or vector qq template. Note: In order to unquote an identifier beginning with @, it is necessary to use either an explicit unquote or to put whitespace after the comma, to avoid colliding with the comma at-sign sequence. Quasiquote expressions can be nested. Substitutions are made only for unquoted components appearing at the same nesting level as the outermost quasiquote. The nesting level increases by one inside each successive quasiquotation, and decreases by one inside each unquotation. A quasiquote expression may return either newly allocated, mutable objects or literal structure for any structure that is constructed at run time during the evaluation of the expression. Portions that do not need to be rebuilt are always literal."))
 ((name . "unquote-splicing") 
  (signature syntax-rules () ((_ expression)))
  (desc . "\"Quasiquote\" expressions are useful for constructing a list or vector structure when some but not all of the desired structure is known in advance. If no commas appear within the qq template, the result of evaluating qq template is equivalent to the result of evaluating 'qq template. If a comma appears within the qq template, however, the expression following the comma is evaluated (\"unquoted\") and its result is inserted into the structure instead of the comma and the expression. If a comma appears followed without intervening whitespace by a commercial at-sign (@), then it is an error if the following expression does not evaluate to a list; the opening and closing parentheses of the list are then \"stripped away\" and the elements of the list are inserted in place of the comma at-sign expression sequence. A comma at-sign normally appears only within a list or vector qq template. Note: In order to unquote an identifier beginning with @, it is necessary to use either an explicit unquote or to put whitespace after the comma, to avoid colliding with the comma at-sign sequence. Quasiquote expressions can be nested. Substitutions are made only for unquoted components appearing at the same nesting level as the outermost quasiquote. The nesting level increases by one inside each successive quasiquotation, and decreases by one inside each unquotation. A quasiquote expression may return either newly allocated, mutable objects or literal structure for any structure that is constructed at run time during the evaluation of the expression. Portions that do not need to be rebuilt are always literal."))
 ((name . "utf8->string")
  (signature
   case-lambda
   (((bytevector? bytevector)) string?)
   (((bytevector? bytevector) (integer? start)) string?)
   (((bytevector? bytevector) (integer? start) (integer? end)) string?))
  (tags pure)
  (desc . "It is an error for bytevector to contain invalid UTF-8 byte sequences. This procedure translates between strings and bytevectors that encode those strings using the UTF-8 encoding. The utf8->string procedure decodes the bytes of a bytevector between start and end and returns the corresponding string."))
 ((name . "values") (signature lambda (obj ...) (values * ...)) (tags pure) (desc . "Delivers all of its arguments to its continuation."))
 ((name . "vector") (signature lambda (obj ...) vector?) (tags pure) (desc . "Returns a newly allocated vector whose elements contain the given arguments. It is analogous to list."))
 ((name . "vector->list")
  (signature
   case-lambda
   (((vector? vector)) list?)
   (((vector? vector) (integer? start)) list?)
   (((vector? vector) (integer? start) (integer? end)) list?))
  (tags pure)
  (desc . "The vector->list procedure returns a newly allocated list of the objects contained in the elements of vector between start and end. The order is preserved."))
 ((name . "vector->string")
  (signature
   case-lambda
   (((vector? vector)) string?)
   (((vector? vector) (integer? start)) string?)
   (((vector? vector) (integer? start) (integer? end)) string?))
  (tags pure)
  (subsigs
    (vector (vector (char? char))))
  (desc . "It is an error if any element of vector between start and end is not a character. The vector->string procedure returns a newly allocated string of the objects contained in the elements of vector between start and end. The order is preserved."))
 ((name . "vector-append")
  (signature lambda ((vector? vector) ...) vector?)
  (tags pure)
  (desc . "Returns a newly allocated vector whose elements are the concatenation of the elements of the given vectors."))
 ((name . "vector-copy")
  (signature
   case-lambda
   (((vector? vector)) vector?)
   (((vector? vector) (integer? start)) vector?)
   (((vector? vector) (integer? start) (integer? end)) vector?))
  (tags pure)
  (desc . "Returns a newly allocated copy of the elements of the given vector between start and end. The elements of the new vector are the same (in the sense of eqv?) as the elements of the old."))
 ((name . "vector-copy!")
  (signature
   case-lambda
   (((vector? to) (integer? at) (vector? from)) undefined)
   (((vector? to) (integer? at) (vector? from) (integer? start)) undefined)
   (((vector? to) (integer? at) (vector? from) (integer? start) (integer? end))
    undefined))
  (desc . "It is an error if at is less than zero or greater than the length of to. It is also an error if (- (vector-length to) at) is less than (- end start). Copies the elements of vector from between start and end to vector to, starting at at. The order in which elements are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary vector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances"))
 ((name . "vector-fill!")
  (signature
   case-lambda
   (((vector? vector) fill) undefined)
   (((vector? vector) fill (integer? start)) undefined)
   (((vector? vector) fill (integer? start) (integer? end)) undefined))
  (desc . "The vector-fill! procedure stores fill in the elements of vector between start and end."))
 ((name . "vector-for-each")
  (signature
   lambda
   ((procedure? proc) (vector? vector1) (vector? vector2) ...)
   undefined)
  (subsigs (proc (lambda (obj ...) undefined)))
  (desc . "It is an error if proc does not accept as many arguments as there are vectors. The arguments to vector-for-each are like the arguments to vector-map, but vector-for-each calls proc for its side effects rather than for its values. Unlike vector-map, vector-for-each is guaranteed to call proc on the elements of the vector s in order from the first element(s) to the last, and the value returned by vector-for-each is unspecified. If more than one vector is given and not all vectors have the same length, vector-for-each terminates when the shortest vector runs out. It is an error for proc to mutate any of the vectors."))
 ((name . "vector-length")
  (signature lambda ((vector? vector)) integer?)
  (tags pure)
  (desc . "Returns the number of elements in vector as an exact integer."))
 ((name . "vector-map")
  (signature
   lambda
   ((procedure? proc) (vector? vector1) (vector? vector2) ...)
   vector?)
  (subsigs (proc (lambda (obj ...) *)))
  (tags pure)
  (desc . "It is an error if proc does not accept as many arguments as there are vectors and return a single value. The vector-map procedure applies proc element-wise to the elements of the vector s and returns a vector of the results, in order. If more than one vector is given and not all vectors have the same length, vector-map terminates when the shortest vector runs out. The dynamic order in which proc is applied to the elements of the vector s is unspecified. If multiple returns occur from vector-map, the values returned by earlier returns are not mutated."))
 ((name . "vector-ref")
  (signature lambda ((vector? vector) (integer? k)) *)
  (tags pure)
  (desc . "It is an error if k is not a valid index of vector. The vector-ref procedure returns the contents of element k of vector."))
 ((name . "vector-set!")
  (signature lambda ((vector? vector) (integer? k) obj) undefined)
  (desc . "It is an error if k is not a valid index of vector. The vector-set! procedure stores obj in element k of vector."))
 ((name . "vector?") (signature lambda (obj) boolean?) (tags pure predicate))
 ((name . "when")
  (signature syntax-rules () ((_ test expression1 expression2 ...)))
  (desc . "The test is evaluated, and if it evaluates to a true value, the expressions are evaluated in order. The result of the when expression is unspecified."))
 ((name . "write-bytevector")
  (signature
   case-lambda
   (((bytevector? bytevector)) undefined)
   (((bytevector? bytevector) (output-port? port)) undefined)
   (((bytevector? bytevector) (output-port? port) (integer? start)) undefined)
   (((bytevector? bytevector)
     (output-port? port)
     (integer? start)
     (integer? end))
    undefined))
  (desc . "Writes the bytes of bytevector from start to end in left-toright order to the binary output port."))
 ((name . "write-char")
  (signature
   case-lambda
   (((char? char)) undefined)
   (((char? char) (output-port? port)) undefined))
  (desc . "Writes the character char (not an external representation of the character) to the given textual output port and returns an unspecified value."))
 ((name . "write-string")
  (signature
   case-lambda
   (((string? string)) undefined)
   (((string? string) (output-port? port)) undefined)
   (((string? string) (output-port? port) (integer? start)) undefined)
   (((string? string) (output-port? port) (integer? start) (integer? end))
    undefined))
  (desc . "Writes the characters of string from start to end in left-toright order to the textual output port."))
 ((name . "write-u8")
  (signature
   case-lambda
   (((integer? byte)) undefined)
   (((integer? byte) (output-port? port)) undefined))
  (desc . "Writes the byte to the given binary output port and returns an unspecified value."))
 ((name . "zero?")
  (signature lambda ((number? z)) boolean?)
  (tags pure predicate)))
